<?xml version="1.0"?>
<!DOCTYPE bindings SYSTEM "chrome://splitbrowser/locale/">
<bindings id="splitbrowserBindings"
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
	xmlns:xbl="http://www.mozilla.org/xbl">

<binding id="contents-in-container" display="xul:vbox">
	<implementation>
		<property name="parentContainer" readonly="true">
			<getter><![CDATA[
				var container = this.parentNode;
				while (container.localName != 'subbrowser-container' &&
						container.parentNode)
				{
					container = container.parentNode;
				}

				return (container.localName == 'subbrowser-container') ? container : null ;
			]]></getter>
		</property>

		<property name="flexibleParent" readonly="true">
			<getter><![CDATA[
				var c = this;
				while (
					c &&
					c != document.documentElement &&
					!c.nextSibling &&
					!c.previousSibling
					)
					c = c.parentNode;

				return c == document.documentElement ? null : c ;
			]]></getter>
		</property>

		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>

		<field name="lastwidth">-1</field>
		<field name="lastheight">-1</field>
	</implementation>
</binding>



<binding id="container" extends="#contents-in-container">
	<!--content orient="vertical">
		<xul:vbox anonid="vertical-container" flex="1"
			class="vertical-container">
			<xul:hbox anonid="horizontal-container" flex="1"
				class="horizontal-container"/>
		</xul:vbox>
	</content-->

	<implementation>
<!--
		<field name="hContainer">null</field>
		<field name="vContainer">null</field>
-->
		<constructor><![CDATA[
			if (
				this.vContainer ||
				this.localName != 'subbrowser-container' ||
				(
					this.hasChildNodes() &&
					this.firstChild.getAttribute('class') == 'vertical-container'
				)
				)
				return;

			this.vContainer = document.createElement('vbox');
			this.vContainer.setAttribute('class', 'vertical-container');
			this.vContainer.setAttribute('flex', 1);
			this.appendChild(this.vContainer);

			this.hContainer = document.createElement('hbox');
			this.hContainer.setAttribute('class', 'horizontal-container');
			this.hContainer.setAttribute('flex', 1);
			this.vContainer.appendChild(this.hContainer);

		]]></constructor>

		<property name="vContentCollapsed" readonly="true"
			onget="return this.vContainer.vContentCollapsed || (this.hContainer ? this.hContainer.vContentCollapsed : false );"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.vContainer.hContentCollapsed || (this.hContainer ? this.hContainer.hContentCollapsed : false );"/>

		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContainer.vContentCompletelyCollapsed &amp;&amp; (this.hContainer ? this.hContainer.vContentCompletelyCollapsed : false );"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.vContainer.hContentCompletelyCollapsed &amp;&amp; (this.hContainer ? this.hContainer.hContentCompletelyCollapsed : false );"/>
	</implementation>

	<handlers>
		<handler event="mousedown"><![CDATA[
			var newEvent = document.createEvent('Events');
			newEvent.force = true;
			newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
			this.dispatchEvent(newEvent);
		]]></handler>
	</handlers>
</binding>

<binding id="horizontal-container" display="xul:hbox">
	<implementation>
		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="vContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].vContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>
		<property name="hContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].hContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>

		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>
		<property name="vContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].vContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
		<property name="hContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].hContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
	</implementation>
</binding>

<binding id="vertical-container" display="xul:vbox">
	<implementation>
		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="vContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].vContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>
		<property name="hContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].hContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>

		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>
		<property name="vContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].vContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
		<property name="hContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].hContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
	</implementation>
</binding>

<binding id="toplevel-container" extends="#container">
	<content orient="vertical">
		<xul:vbox anonid="primary-browser-inner-container" flex="1">
			<xul:vbox anonid="vertical-container" flex="1"
				class="vertical-container">
				<xul:hbox anonid="horizontal-container" flex="1"
					class="horizontal-container">
					<xul:vbox anonid="primary-browser-wrapper" flex="1"
						class="primary-browser-wrapper"
						name="_top">
						<children/>
					</xul:vbox>
				</xul:hbox>
			</xul:vbox>
		</xul:vbox>
	</content>

	<implementation>
		<property name="hContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'horizontal-container'); } catch(e) { return null; }"/>
		<property name="vContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-container'); } catch(e) { return null; }"/>
		<property name="contentWrapper" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'primary-browser-wrapper'); } catch(e) { return null; }"/>

		<property name="innerContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'primary-browser-inner-container'); } catch(e) { return null; }"/>
	</implementation>
</binding>



<binding id="subbrowser-base" extends="#contents-in-container">
	<implementation>
		<property name="rightOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxY > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="bottomOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxX > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="contentAreaSizeObject" readonly="true">
			<getter><![CDATA[
				if (!this.browser) return null;
				var box, retVal;
				if (this.localName == 'subbrowser') {
					if (this.browser.localName == 'tabbrowser')
						box = this.browser.mCurrentBrowser;
					else
						box = this.browser;
				}
				else
					box = gBrowser.mCurrentBrowser;

				retVal =  { box : box };

				box = box.boxObject;
				retVal.x       = box.x;
				retVal.y       = box.y;
				retVal.screenX = box.screenX;
				retVal.screenY = box.screenY;
				retVal.width   = box.width - this.rightOffset;
				retVal.height  = box.height - this.bottomOffset;

				retVal.middleX = parseInt(box.x + (box.width / 2));
				retVal.middleY = parseInt(box.y + (box.height / 2));
				retVal.middleScreenX = parseInt(box.screenX + (box.width / 2));
				retVal.middleScreenY = parseInt(box.screenY + (box.height / 2));

				retVal.areaWidth   = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.width * 0.6));
				retVal.areaX       = retVal.middleX - parseInt(retVal.areaWidth / 2);
				retVal.areaScreenX = retVal.middleScreenX - parseInt(retVal.areaWidth / 2);
				retVal.areaHeight  = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.height * 0.6));
				retVal.areaY       = retVal.middleY - parseInt(retVal.areaHeight / 2);
				retVal.areaScreenY = retVal.middleScreenY - parseInt(retVal.areaHeight / 2);

				return retVal;
			]]></getter>
		</property>

		<property name="src" readonly="true"
			onget="return gBrowser.currentURI.spec;"/>
		<property name="contentWindow"
			readonly="true"
			onget="return gBrowser.contentWindow;"/>

		<method name="toggleCollapsed">
			<body><![CDATA[
				if (this.contentCollapsed)
					this.expand();
				else
					this.collapse();
			]]></body>
		</method>

		<method name="collapse">
			<body><![CDATA[
				var c = this.flexibleParent;
				if (!c) return;

				var splitter = c.nextSibling || c.previousSibling;
				var prop     = (splitter.getAttribute('orient') != 'vertical') ? 'width' : 'height' ;
				var cProp    = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;
				var cCProp   = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCompletelyCollapsed' : 'vContentCompletelyCollapsed' ;

				if (this[cProp]) return;

				var sideBox = this.findSideBox(
						c,
						(c.getAttribute('splitter') == 'before' ? -1 : 1 ),
						(splitter.getAttribute('orient') != 'vertical' ? 'horizontal' : 'vertical' )
					);
				if (!sideBox) return;

/*
var col = (['red', 'blue', 'green'])[parseInt(Math.random() * 3)];
c.setAttribute('style', 'border: 2px dotted '+col+' !important;');
sideBox.setAttribute('style', 'border: 2px solid '+col+' !important;');
window.setTimeout(function() {
c.removeAttribute('style');
sideBox.removeAttribute('style');
}, 2000);
*/

				var origSize = c.boxObject[prop];
				var sideSize = sideBox.boxObject[prop];

				c['last'+prop] = origSize;
				c.setAttribute(prop, 0);
				sideBox.removeAttribute('max'+prop);
				sideBox.setAttribute(prop, sideSize + origSize);
				c.setAttribute('max'+prop, 0);
				this.blur();

				window.setTimeout(function(aThis) {
					aThis.toggleNavigation(false);
					aThis.mUpdateToolbarMode();

					var node = c.parentNode;
					var appcontent = document.getElementById('appcontent');
					while (node && node != appcontent)
					{
						if (cCProp in node && node[cCProp])
							node.setAttribute('max'+prop, 0);
						node = node.parentNode;
					}
				}, 0, this);
			]]></body>
		</method>

		<method name="expand">
			<parameter name="aForce"/>
			<body><![CDATA[
				var c = this.flexibleParent;
				if (!c) return;

				var splitter = c.nextSibling || c.previousSibling;
				var prop     = (splitter.getAttribute('orient') == 'horizontal') ? 'width' : 'height' ;
				var cProp    = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;

				if (!this[cProp]) return;

				var sideBox = this.findSideBox(
						c,
						(c.getAttribute('splitter') == 'before' ? -1 : 1 ),
						(splitter.getAttribute('orient') != 'vertical' ? 'horizontal' : 'vertical' )
					);
				if (!sideBox) return;

/*
var col = (['red', 'blue', 'green'])[parseInt(Math.random() * 3)];
c.setAttribute('style', 'border: 2px dotted '+col+' !important;');
sideBox.setAttribute('style', 'border: 2px solid '+col+' !important;');
window.setTimeout(function() {
c.removeAttribute('style');
sideBox.removeAttribute('style');
}, 2000);
*/

				var origSize = c.boxObject[prop];
				var sideSize = sideBox.boxObject[prop];

				var node = c;
				var appcontent = document.getElementById('appcontent');
				var sideBoxPos = 'before';
				do {
					node.removeAttribute('max'+prop);
					if (node.nextSibling && node.nextSibling.nextSibling == sideBox)
						sideBoxPos = 'after';
					node = node.parentNode;
				}
				while (node && node != appcontent)

				if (c['last'+prop] === void(0) || c['last'+prop] <= 0)
					c['last'+prop] = parseInt(sideSize * 2 / 5);
				c.setAttribute(prop, c['last'+prop]);
				sideBox.setAttribute(prop, sideSize - (c['last'+prop] - origSize));
				c['last'+prop] = -1;

				this.clearMaxSizeProp(
					((sideBoxPos == 'after') ? sideBox.previousSibling.previousSibling : sideBox.nextSibling.nextSibling ),
					prop
				);


				window.setTimeout(function(aThis) {
					aThis.toggleNavigation((aThis.getAttribute('toolbar-navigation') == 'true'));
					aThis.mUpdateToolbarMode();
				}, 0, this);
			]]></body>
		</method>
		<method name="clearMaxSizeProp">
			<parameter name="aNode"/>
			<parameter name="aProp"/>
			<body><![CDATA[
				aNode.removeAttribute('max'+aProp);
				if (aNode['last'+aProp]) aNode['last'+aProp] = -1;
				if (aNode == this) return;
				for (var i = 0, maxi = aNode.childNodes.length; i < maxi; i = i+2)
				{
					this.clearMaxSizeProp(aNode.childNodes[i], aProp);
				}
			]]></body>
		</method>


		<method name="findSideBox">
			<parameter name="aBox"/>
			<parameter name="aDir"/>
			<parameter name="aOrient"/>
			<parameter name="aFindAny"/>
			<body><![CDATA[
				var cProp  = (aOrient != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;

				var target = aBox;
				if (aDir < 0) {
					while (target && target.previousSibling)
					{
						target = target.previousSibling.previousSibling;
						if (aFindAny || !target[cProp]) return target;
					}

					target = aBox;
					while (target && target.nextSibling)
					{
						target = target.nextSibling.nextSibling;
						if (aFindAny || !target[cProp]) return target;
					}
				}
				else {
					while (target && target.nextSibling)
					{
						target = target.nextSibling.nextSibling;
						if (aFindAny || !target[cProp]) return target;
					}

					target = aBox;
					while (target && target.previousSibling)
					{
						target = target.previousSibling.previousSibling;
						if (aFindAny || !target[cProp]) return target;
					}
				}

				var appcontent = document.getElementById('appcontent');

				target = aBox;
				var orientBox;
				do {
					target = target.parentNode;

					orientBox = (target.localName == 'subbrowser-container') ? (target.previousSibling || target.nextSibling || target.parentNode) : target ;
					if (orientBox.localName == 'splitter') {
						if (orientBox.getAttribute('orient') != aOrient)
							continue;
						else
							break;
					}
					else {
						if (window.getComputedStyle(orientBox, '').getPropertyValue('-moz-box-orient') != aOrient)
							continue;
						else
							break;
					}
				}
				while (target != appcontent);

				if (target == appcontent)
					return null;
				else
					return this.findSideBox(target, aDir, aOrient);
			]]></body>
		</method>


		<method name="toggleSyncScroll">
			<body><![CDATA[
				this.syncScroll = !this.syncScroll;
				if (this.syncScroll) {
					var subbrowser = this;
					if (SplitBrowser.mainBrowserBox.syncScroll)
						subbrowser = SplitBrowser.mainBrowserBox;
					subbrowser.notifyScroll(subbrowser.browser.contentWindow);
				}
			]]></body>
		</method>
		<property name="syncScroll"
			onget="return this.getAttribute('sync-scroll') == 'true';"
			onset="if (val) this.setAttribute('sync-scroll', true); else this.removeAttribute('sync-scroll'); return val ? true : false ;"/>
		<method name="onContentScroll">
			<parameter name="aEvent"/>
			<body><![CDATA[
				if (!this.syncScroll ||
					this.scrollSynchronizing ||
					!(aEvent.originalTarget instanceof Document)) return;
				this.notifyScroll(aEvent.originalTarget.defaultView);
			]]></body>
		</method>
		<method name="notifyScroll">
			<parameter name="aFrame"/>
			<body><![CDATA[
				// ignore background tabs
				if (aFrame.top != this.browser.contentWindow) return;
				var info = {
						x    : aFrame.scrollX,
						maxX : aFrame.scrollMaxX,
						y    : aFrame.scrollY,
						maxY : aFrame.scrollMaxY
					};
				var os = Components.classes['@mozilla.org/observer-service;1']
							.getService(Components.interfaces.nsIObserverService);
				os.notifyObservers(aFrame, 'subbrowser:syncScroll', info.toSource());
			]]></body>
		</method>
		<field name="syncScrollObserver"><![CDATA[
		({
			mOwner : this,
			observe: function(aSubject, aTopic, aData)
			{
				if (!this.mOwner.syncScroll) return;

				// in other windows
				if (aSubject.top
					.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
					.getInterface(Components.interfaces.nsIWebNavigation)
					.QueryInterface(Components.interfaces.nsIDocShell)
					.QueryInterface(Components.interfaces.nsIDocShellTreeItem)
					.parent
					.QueryInterface(Components.interfaces.nsIDocShell)
					.QueryInterface(Components.interfaces.nsIWebNavigation)
					.document.defaultView != window) return;

				var w = this.mOwner.browser.contentWindow;
				if (aSubject.top == w) return;

				var info;
				eval('info = '+aData);
				this.mOwner.scrollSynchronizing = true;
				w.scrollTo(
					(
						SplitBrowser.getPref('splitbrowser.syncScroll.horizontal') ?
							(info.x / info.maxX * w.scrollMaxX) : w.scrollX
					),
					(
						SplitBrowser.getPref('splitbrowser.syncScroll.vertical') ?
							(info.y / info.maxY * w.scrollMaxY) : w.scrollY
					)
				);
				window.setTimeout(function(aOwner) {
					aOwner.scrollSynchronizing = false;
				}, 0, this.mOwner);
			}
		})
		]]></field>


		<property name="name"
			onget="return this.getAttribute('name') || '';"
			onset="this.setAttribute('name', val); return val;"/>



		<method name="checkEventFiredOnEdge">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<body><![CDATA[
				if (this.contentCollapsed) {
					return {
						isTop    : false,
						isBottom : false,
						isLeft   : false,
						isRight  : false
					};
				}

				var offset   = SplitBrowser.addButtonSize;
				var box      = this.contentAreaSizeObject;
				if (!box) return null;

				if (aForceFire || aEvent.ctrlKey) {
					var pos = SplitBrowser.getDropPositionOnContentArea(aEvent, box.box);
					return {
						isTop    : pos == SplitBrowser.POSITION_TOP,
						isBottom : pos == SplitBrowser.POSITION_BOTTOM,
						isLeft   : pos == SplitBrowser.POSITION_LEFT,
						isRight  : pos == SplitBrowser.POSITION_RIGHT
					};
				}

				var isTop    = (aEvent.screenY >= box.screenY &&
								aEvent.screenY < box.screenY+offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isBottom = (aEvent.screenY <= box.screenY+box.height &&
								aEvent.screenY > box.screenY+box.height-offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isLeft   = (aEvent.screenX >= box.screenX &&
								aEvent.screenX < box.screenX+offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);
				var isRight  = (aEvent.screenX <= box.screenX+box.width &&
								aEvent.screenX > box.screenX+box.width-offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);

				return {
					isTop    : isTop,
					isBottom : isBottom,
					isLeft   : isLeft,
					isRight  : isRight
				};
			]]></body>
		</method>

		<method name="handleMouseOverEvent">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<parameter name="aModifierPressed"/>
			<body><![CDATA[
				var check = this.checkEventFiredOnEdge(aEvent, aForceFire);
				if (!check) return;

				if (
					check.isTop ||
					check.isBottom ||
					check.isLeft ||
					check.isRight
					) {
					if (
						(check.isTop && !this.mIsMouseOverTop) ||
						(check.isBottom && !this.mIsMouseOverBottom) ||
						(check.isLeft && !this.mIsMouseOverLeft) ||
						(check.isRight && !this.mIsMouseOverRight)
						) {
						this.mIsMouseOverTop    = check.isTop;
						this.mIsMouseOverBottom = check.isBottom;
						this.mIsMouseOverLeft   = check.isLeft;
						this.mIsMouseOverRight  = check.isRight;

						var newEvent = document.createEvent('Events');
						newEvent.initEvent('SubBrowserEnterContentAreaEdge', false, true);
						newEvent.isTop    = check.isTop;
						newEvent.isBottom = check.isBottom;
						newEvent.isLeft   = check.isLeft;
						newEvent.isRight  = check.isRight;
						newEvent.targetSubBrowser = this;
						newEvent.firedBy = aEvent.type;
						newEvent.modifierKeyPressed = aModifierPressed;
						this.dispatchEvent(newEvent);
					}
				}
				else if (
					this.mIsMouseOverTop ||
					this.mIsMouseOverBottom ||
					this.mIsMouseOverLeft ||
					this.mIsMouseOverRight
					) {
					this.mIsMouseOverTop    = false;
					this.mIsMouseOverBottom = false;
					this.mIsMouseOverLeft   = false;
					this.mIsMouseOverRight  = false;

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
					this.dispatchEvent(newEvent);
				}
			]]></body>
		</method>

		<method name="handleDragOverEvent">
			<parameter name="aEvent"/>
			<body><![CDATA[
				const DragService = Components.classes['@mozilla.org/widget/dragservice;1'].getService(Components.interfaces.nsIDragService);
				var session = DragService.getCurrentSession();
				if (!session) return;

				var isSubBrowser = session.isDataFlavorSupported('application/x-moz-splitbrowser');
				if (isSubBrowser ||
					session.isDataFlavorSupported('application/x-moz-tabbrowser-tab') ||
					session.isDataFlavorSupported('text/x-moz-url') ||
					session.isDataFlavorSupported('text/unicode') ||
					session.isDataFlavorSupported('application/x-moz-file')) {
					this.handleMouseOverEvent(aEvent, isSubBrowser);
					var check = this.checkEventFiredOnEdge(aEvent, isSubBrowser);
					if (!check) return;
					if (
						SplitBrowser.isLinux &&
						SplitBrowser.addButton.targetSubBrowser == this &&
						(
							check.isTop ||
							check.isBottom ||
							check.isLeft ||
							check.isRight
						)
						) {
						session.canDrop = true;
						aEvent.stopPropagation();
					}
				}
			]]></body>
		</method>


		<property name="focused">
			<setter><![CDATA[
				if (this.contentCollapsed)
					val = false;

				var b = this.browser;
				if (b && b.localName == 'tabbrowser')
					b = b.mCurrentBrowser;

				if (val || !SplitBrowser.browsers.length) {
					this.setAttribute('subbrowser-focused', true);
					if (b) {
						b.removeAttribute('type');
						b.setAttribute('type', 'content-primary');
					}
				}
				else if (SplitBrowser.browsers.length) {
					this.removeAttribute('subbrowser-focused');
					if (b) {
						b.removeAttribute('type');
						b.setAttribute('type', 'content');
					}
				}
				return val;
			]]></setter>
			<getter><![CDATA[
				return this.getAttribute('subbrowser-focused') == 'true';
			]]></getter>
		</property>

		<method name="focus">
			<body><![CDATA[
				if (SplitBrowser.activeSubBrowser != this)
					SplitBrowser.activeSubBrowser = this;
				this.focused = true;
			]]></body>
		</method>
		<method name="blur">
			<body><![CDATA[
				if (SplitBrowser.activeSubBrowser == this)
					SplitBrowser.activeSubBrowser = null;
				this.focused = false;
				this.isUrlbarFocused = false;
			]]></body>
		</method>

		<method name="autoFocus">
			<body><![CDATA[
				var delay = SplitBrowser.subBrowserAutoFocusDelay;
				if (
					this.focused ||
					this.mAutoFocusTimer ||
					delay < 0
					)
					return;

				this.mAutoFocusTimer = window.setTimeout(
					function(aThis) {
						aThis.focus();
						aThis.cancelAutoFocus();
					},
					delay,
					this
				);
			]]></body>
		</method>
		<method name="cancelAutoFocus">
			<body><![CDATA[
				if (this.mAutoFocusTimer) {
					window.clearInterval(this.mAutoFocusTimer);
					this.mAutoFocusTimer = null;
				}
			]]></body>
		</method>
		<field name="mAutoFocusTimer">null</field>

	</implementation>

	<handlers>
		<handler event="mousemove"
			action="var type = SplitBrowser.getPref('splitbrowser.show.addbuttons.hover.type'); var isModifier = type == 1 &amp;&amp; SplitBrowser.modifierKeyPressed; if (type == 0 || isModifier) this.handleMouseOverEvent(event, false, isModifier); return true;"/>
		<handler event="dragover" phase="capturing"
			action="if (SplitBrowser.getPref('splitbrowser.show.addbuttons.dragdrop')) this.handleDragOverEvent(event); return true;"/>

		<handler event="focus" phase="capturing"
			action="this.focus();"/>

		<handler event="scroll" phase="capturing"
			action="this.onContentScroll(event);"/>

		<handler event="mouseover"
			action="window.setTimeout(function(aThis) { if (aThis.autoFocus) aThis.autoFocus(); }, 0, this);"/>
		<handler event="mouseout"
			action="this.cancelAutoFocus();"/>
	</handlers>
</binding>

<binding id="subbrowser-primary" extends="#subbrowser-base">
	<implementation>
		<property name="vContentCollapsed" readonly="true"
			onget="return this.boxObject.width == 0;"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.boxObject.height == 0;"/>
		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCollapsed"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.hContentCollapsed"/>
		<property name="browser" readonly="true"
			onget="return gBrowser;"/>

		<property name="syncScroll"
			onget="return SplitBrowser.getPref('splitbrowser.syncScroll.mainArea');"
			onset="SplitBrowser.setPref('splitbrowser.syncScroll.mainArea', val ? true : false ); return val ? true : false ;"/>

		<constructor><![CDATA[
			var os = Components.classes['@mozilla.org/observer-service;1']
						.getService(Components.interfaces.nsIObserverService);
			os.addObserver(this.syncScrollObserver, 'subbrowser:syncScroll', false);
		]]></constructor>
		<destructor><![CDATA[
			var os = Components.classes['@mozilla.org/observer-service;1']
						.getService(Components.interfaces.nsIObserverService);
			os.removeObserver(this.syncScrollObserver, 'subbrowser:syncScroll');
		]]></destructor>
	</implementation>
</binding>

<binding id="subbrowser" extends="#subbrowser-base">
	<content orient="vertical"
		context="_child">
		<xul:menupopup anonid="contextmenu"
			onpopupshowing="
				SplitBrowser.getSubBrowserFromChild(this).resetNavigation();
				SplitBrowser.getSubBrowserFromChild(this).updateContextMenu(event);
			"
			oncommand="SplitBrowser.getSubBrowserFromChild(this).resetNavigation();"
			ondraggesture="event.stopPropagation();">
			<xul:menuitem class="subbrowser-context-close"
				label="&splitbrowser.subbrowser.menu.close;"
				oncommand="SplitBrowser.getSubBrowserFromChild(this).close();"/>
			<xul:menuitem class="subbrowser-context-collapse"
				label="&splitbrowser.subbrowser.menu.collapse;"
				oncommand="SplitBrowser.getSubBrowserFromChild(this).collapse();"/>
			<xul:menuitem class="subbrowser-context-expand"
				label="&splitbrowser.subbrowser.menu.expand;"
				oncommand="SplitBrowser.getSubBrowserFromChild(this).expand();"/>
			<xul:menuseparator/>
			<xul:menuitem class="subbrowser-context-openNewTab"
				label="&splitbrowser.subbrowser.menu.openNewTab;"
				oncommand="SplitBrowser.getSubBrowserFromChild(this).openNewTab();"/>
			<xul:menuseparator/>
			<xul:menuitem class="subbrowser-context-syncScroll"
				label="&splitbrowser.subbrowser.menu.syncScroll;"
				type="checkbox"
				autocheck="false"
				oncommand="SplitBrowser.getSubBrowserFromChild(this).toggleSyncScroll();"/>
		</xul:menupopup>
		<xul:hbox flex="1" class="subbrowser-content">
			<xul:toolbox anonid="subbrowser-toolbox-vertical"
				orient="vertical"
				class="subbrowser-toolbox subbrowser-toolbox-vertical">
			<xul:toolbar anonid="subbrowser-toolbar-vertical"
				orient="vertical"
				flex="1"
				class="subbrowser-toolbar subbrowser-toolbar-vertical"
				align="center"
			 	ondraggesture="
			 		SplitBrowser.getSubBrowserFromChild(this).resetNavigation();
			 		nsDragAndDrop.startDrag(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);
			 	"
				ondragdrop="nsDragAndDrop.drop(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
				ondragover="nsDragAndDrop.dragOver(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
				onclick="if (event.button == 1) SplitBrowser.getSubBrowserFromChild(this).toggleCollapsed();"
				ondblclick="SplitBrowser.getSubBrowserFromChild(this).toggleCollapsed();">
				<xul:toolbarbutton
					anonid="close-button-vertical"
					class="tabs-closebutton toolbarbutton-1"
					tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
					oncommand="SplitBrowser.getSubBrowserFromChild(this).close();"
					ondblclick="event.stopPropagation();"/>
				<xul:toolbarbutton
					anonid="collapse-button-vertical"
					tooltiptext="&splitbrowser.subbrowser.collapse.tooltip;"
					oncommand="SplitBrowser.getSubBrowserFromChild(this).collapse();"
					ondblclick="event.stopPropagation();"
					class="subbrowser-toolbar-item button collapse"/>
				<xul:toolbarbutton
					anonid="expand-button-vertical"
					tooltiptext="&splitbrowser.subbrowser.expand.tooltip;"
					oncommand="SplitBrowser.getSubBrowserFromChild(this).expand();"
					ondblclick="event.stopPropagation();"
					class="subbrowser-toolbar-item button expand"/>
				<xul:toolbarbutton
					anonid="syncScroll-button-vertical"
					tooltiptext="&splitbrowser.subbrowser.syncScroll.tooltip;"
					oncommand="SplitBrowser.getSubBrowserFromChild(this).toggleSyncScroll();"
					ondblclick="event.stopPropagation();"
					class="subbrowser-toolbar-item button syncScroll"
					type="checkbox"
					autoCheck="false"
					xbl:inherits="checked=sync-scroll"/>
				<xul:box class="subbrowser-toolbar-item favicon-box">
					<xul:image class="subbrowser-toolbar-item favicon"
						anonid="vertical-favicon"
						validate="never"
						onerror="SplitBrowser.getSubBrowserFromChild(this).addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
				</xul:box>
				<xul:description anonid="vertical-title"
					class="subbrowser-title subbrowser-vertical-title"
					flex="1"/>
			</xul:toolbar>
			</xul:toolbox>
			<xul:vbox flex="1">
				<xul:toolbox anonid="subbrowser-toolbox-horizontal"
					orient="horizontal"
					class="subbrowser-toolbox subbrowser-toolbox-horizontal">
				<xul:toolbar anonid="subbrowser-toolbar-horizontal"
					class="subbrowser-toolbar subbrowser-toolbar-horizontal"
					align="center"
					flex="1"
				 	ondraggesture="
				 		SplitBrowser.getSubBrowserFromChild(this).resetNavigation();
				 		nsDragAndDrop.startDrag(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);
				 	"
					ondragdrop="nsDragAndDrop.drop(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
					ondragover="nsDragAndDrop.dragOver(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
				 	onclick="
				 		if (event.button == 0 &amp;&amp;
				 			this.firstChild.getAttribute('selectedIndex') == '0')
							SplitBrowser.getSubBrowserFromChild(this).resetNavigation();
				 		if (event.button == 1)
				 			SplitBrowser.getSubBrowserFromChild(this).toggleCollapsed();
				 	"
					ondblclick="SplitBrowser.getSubBrowserFromChild(this).toggleCollapsed();">
					<xul:toolbarbutton
						anonid="syncScroll-button-horizontal"
						tooltiptext="&splitbrowser.subbrowser.syncScroll.tooltip;"
						oncommand="SplitBrowser.getSubBrowserFromChild(this).toggleSyncScroll();"
						ondblclick="event.stopPropagation();"
						class="subbrowser-toolbar-item button syncScroll"
						type="checkbox"
						autoCheck="false"
						xbl:inherits="checked=sync-scroll"/>
					<xul:stack anonid="toolbar-deck"
						flex="1"
						onmouseover="SplitBrowser.getSubBrowserFromChild(this).toggleNavigationOnHover(true);"
						onmouseout="SplitBrowser.getSubBrowserFromChild(this).toggleNavigationOnHover(false);"
						selectedIndex="0">
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center"
							anonid="toolbar-deck-titlebar">
							<xul:box class="subbrowser-toolbar-item favicon-box">
								<xul:image class="subbrowser-toolbar-item favicon"
									anonid="favicon"
									validate="never"
									ondraggesture="nsDragAndDrop.startDrag(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
									onerror="SplitBrowser.getSubBrowserFromChild(this).addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
							</xul:box>
							<xul:stack flex="1">
								<xul:progressmeter class="subbrowser-toolbar-item progress"
									anonid="progressmeter"
									collapsed="true"
									flex="1"/>
								<xul:label anonid="title"
									class="subbrowser-title"
									blank-label="&splitbrowser.subbrowser.blank;"
									loading-label="&splitbrowser.subbrowser.loading;"
									flex="1"
									crop="end"/>
							</xul:stack>
						</xul:hbox>
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center"
							anonid="toolbar-deck-navbar">
							<xul:toolbarbutton
								anonid="back-button"
								tooltiptext="&splitbrowser.subbrowser.goBack.tooltip;"
								oncommand="SplitBrowser.getSubBrowserFromChild(this).goBack();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button goBack"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="forward-button"
								tooltiptext="&splitbrowser.subbrowser.goForward.tooltip;"
								oncommand="SplitBrowser.getSubBrowserFromChild(this).goForward();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button goForward"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="reload-button"
								tooltiptext="&splitbrowser.subbrowser.reload.tooltip;"
								oncommand="SplitBrowser.getSubBrowserFromChild(this).reload(event.shiftKey);"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button reload"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="stop-button"
								tooltiptext="&splitbrowser.subbrowser.stop.tooltip;"
								oncommand="SplitBrowser.getSubBrowserFromChild(this).stop();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button stop"
								disabled="true"/>
							<xul:hbox class="subbrowser-toolbar-item urlbar-box"
								align="center"
								flex="1">
								<xul:stack flex="1">
									<xul:progressmeter class="subbrowser-toolbar-item urlbar-progress"
										anonid="urlbar-progressmeter"
										collapsed="true"
										flex="1"/>
									<xul:textbox flex="1"
										anonid="urlbar"
										class="subbrowser-toolbar-item urlbar-textbox"
										ontextentered="SplitBrowser.getSubBrowserFromChild(this).load(this.value);"
										ontextreverted="SplitBrowser.getSubBrowserFromChild(this).load(this.value);"
										onfocus="SplitBrowser.getSubBrowserFromChild(this).isUrlbarFocused = true;"
										onclick="event.stopPropagation();"
										ondblclick="event.stopPropagation();"
										sizetopopup="pref"
										clickSelectsAll="true"
										type="autocomplete"
										autocompletesearch="history"
										autocompletepopup="PopupAutoComplete"
										completeselectedindex="true"
										tabscrolling="true"
										showcommentcolumn="true"
										enablehistory="true">
										<xul:box class="subbrowser-toolbar-item urlbar-favicon-box">
											<xul:image class="subbrowser-toolbar-item urlbar-favicon"
												anonid="urlbar-favicon"
												validate="never"
												onerror="SplitBrowser.getSubBrowserFromChild(this).addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
										</xul:box>
									</xul:textbox>
								 </xul:stack>
							</xul:hbox>
							<xul:toolbarbutton
								anonid="go-button"
								class="subbrowser-toolbar-item go"
								label="&splitbrowser.subbrowser.go.label;"
								tooltiptext="&splitbrowser.subbrowser.go.tooltip;"
								oncommand="SplitBrowser.getSubBrowserFromChild(this).go();"
								ondblclick="event.stopPropagation();"/>
						</xul:hbox>
					</xul:stack>
					<xul:toolbarbutton
						anonid="collapse-button"
						tooltiptext="&splitbrowser.subbrowser.collapse.tooltip;"
						oncommand="SplitBrowser.getSubBrowserFromChild(this).collapse();"
						ondblclick="event.stopPropagation();"
						class="subbrowser-toolbar-item button collapse"/>
					<xul:toolbarbutton
						anonid="expand-button"
						tooltiptext="&splitbrowser.subbrowser.expand.tooltip;"
						oncommand="SplitBrowser.getSubBrowserFromChild(this).expand();"
						ondblclick="event.stopPropagation();"
						class="subbrowser-toolbar-item button expand"/>
					<xul:toolbarbutton
						anonid="close-button"
						class="tabs-closebutton toolbarbutton-1"
						tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
						oncommand="SplitBrowser.getSubBrowserFromChild(this).close();"
						ondblclick="event.stopPropagation();"/>
				</xul:toolbar>
				</xul:toolbox>
				<xul:hbox class="subbrowser-browser-box"
					flex="1"
					onkeypress="if ('findBar_OnBrowserKeyPress' in window) findBar_OnBrowserKeyPress(event);"
					onmouseup="if ('findBar_OnBrowserMouseUp' in window) findBar_OnBrowserMouseUp(event);">
					<xul:tabbrowser anonid="browser-tabbrowser"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onnewtab="
							var node = this;
							while (node.localName != 'tabbrowser') {
								node = node.parentNode;
							}
							node.parentNode.openNewTab();
						"
						onclick="return contentAreaClick(event, SplitBrowser.fieldNormalClicks(SplitBrowser.getSubBrowserFromChild(this).name));"
						ondragdrop="nsDragAndDrop.drop(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
						content="about:blank"
						contenttooltip="aHTMLTooltip"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"
						disablehistory="true"/>
					<xul:browser anonid="browser-simple"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onclick="return contentAreaClick(event, false);"
						ondragdrop="nsDragAndDrop.drop(event, SplitBrowser.getSubBrowserFromChild(this).pageDNDObserver);"
						content="about:blank"
						contenttooltip="aHTMLTooltip"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"/>
				</xul:hbox>
			</xul:vbox>
		</xul:hbox>
	</content>

	<implementation>
		<property name="toolbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbar-horizontal');"/>

		<property name="hToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-horizontal');"/>
		<property name="vToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-vertical');"/>

		<property name="toolbarDeck" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar-deck');"/>

		<property name="browser" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'browser-'+this.browserType);"/>
		<property name="browserType" readonly="true"
			onget="return this.getAttribute('browsertype') == 'simple' ? 'simple' : 'tabbrowser' ;"/>

		<property name="backButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'back-button');"/>
		<property name="forwardButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'forward-button');"/>
		<property name="reloadButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'reload-button');"/>
		<property name="stopButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'stop-button');"/>
		<property name="urlbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar');"/>
		<property name="title" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'title');"/>
		<property name="vTitle" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-title');"/>
		<property name="favicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'favicon');"/>
		<property name="vFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-favicon');"/>
		<property name="urlbarFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-favicon');"/>
		<property name="progressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'progressmeter');"/>
		<property name="urlbarProgressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-progressmeter');"/>
		<property name="goButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'go-button');"/>
		<property name="contextmenu" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'contextmenu');"/>

		<property name="src"
			onset="this.setAttribute('src', val); this.load(val); return val;"
			onget="return this.getAttribute('src') || 'about:blank';"/>
		<property name="contentWindow"
			readonly="true"
			onget="return this.browser.contentWindow;"/>


		<property name="isIeTab" readonly="true"
			onget="return ('IeTab' in window &amp;&amp; this.browser.currentURI.spec.indexOf(gIeTabChromeStr) == 0);"/>
		<method name="getIeTabOf">
			<parameter name="aBrowser"/>
			<body><![CDATA[
				if (!('IeTab' in window)) return null;
				if (
					aBrowser &&
					aBrowser.currentURI &&
					gIeTab.startsWith(aBrowser.currentURI.spec, gIeTabChromeStr)
					) {
					if (aBrowser.contentDocument &&
						aBrowser.contentDocument.getElementById('IETab')) {
						var obj = aBrowser.contentDocument.getElementById('IETab');
						return (obj.wrappedJSObject ? obj.wrappedJSObject : obj );
					}
				}
				return null;
			]]></body>
		</method>


		<method name="load">
			<parameter name="aURI"/>
			<body><![CDATA[
				if (!aURI) aURI = 'about:blank';
				this.browser.loadURI(aURI);
				this.setAttribute('src', aURI);
			]]></body>
		</method>

		<method name="goBack">
			<body><![CDATA[
				if (this.browser.canGoBack) {
					this.browser.goBack();
				}
			]]></body>
		</method>
		<method name="goForward">
			<body><![CDATA[
				if (this.browser.canGoForward) {
					this.browser.goForward();
				}
			]]></body>
		</method>
		<method name="reload">
			<parameter name="aBypassCache"/>
			<body><![CDATA[
				if (aBypassCache) {
					var webNav = this.browser.webNavigation;
					try {
						var sh = webNav.sessionHistory;
						if (sh)
							webNav = sh.QueryInterface(Components.interfaces.nsIWebNavigation);
					}
					catch(e) {
					}
					const reloadFlags = webNav.LOAD_FLAGS_BYPASS_PROXY | webNav.LOAD_FLAGS_BYPASS_CACHE;
					try {
						webNav.reload(reloadFlags);
					}
					catch(e) {
					}
				}
				else
					this.browser.reload();
			]]></body>
		</method>
		<method name="stop">
			<body><![CDATA[
				this.browser.stop();
			]]></body>
		</method>

		<method name="go">
			<body><![CDATA[
				this.load(this.urlbar.value);
			]]></body>
		</method>

		<method name="close">
			<body><![CDATA[
				var event = document.createEvent('Events');
				event.initEvent('SubBrowserRemoveRequest', false, true);
				this.dispatchEvent(event);
			]]></body>
		</method>


		<property name="minSize" readonly="true">
			<getter><![CDATA[
				if (this.mMinSize < 0)
					this.mMinSize = Math.max(this.vToolbox.boxObject.width, this.hToolbox.boxObject.height) * 2;

				return this.mMinSize;
			]]></getter>
		</property>
		<field name="mMinSize">
			-1
		</field>

		<property name="vContentCollapsed" readonly="true"
			onget="return this.boxObject.height &lt;= this.minSize;"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.boxObject.width &lt;= this.minSize;"/>
		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCollapsed"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.hContentCollapsed"/>

		<method name="updateContextMenu">
			<parameter name="aEvent"/>
			<body><![CDATA[
				var popup = this.contextmenu;
				var collapsed = this.contentCollapsed;
				popup.getElementsByAttribute('class', 'subbrowser-context-collapse')[0].hidden = collapsed;
				popup.getElementsByAttribute('class', 'subbrowser-context-expand')[0].hidden = !collapsed;

				var tabItem = popup.getElementsByAttribute('class', 'subbrowser-context-openNewTab')[0];
				tabItem.hidden = tabItem.previousSibling.hidden = (this.browser.localName != 'tabbrowser');

				var syncItem = popup.getElementsByAttribute('class', 'subbrowser-context-syncScroll')[0];
				if (this.syncScroll)
					syncItem.setAttribute('checked', true);
				else
					syncItem.removeAttribute('checked');
			]]></body>
		</method>



		<method name="updateToolbarForCurrentTab">
			<parameter name="aSwitchTab"/>
			<body><![CDATA[
				var b      = this.browser;
				var t      = null;
				var isBusy = this.mIsBusy;
				var ietab  = this.getIeTabOf(this.browser);
				if (aSwitchTab) {
					t = b.mCurrentTab;
					isBusy = (t.getAttribute('busy') == 'true');
					this.mTotalProgress = t.mSubbrowserTabTotalProgress || 0 ;
				}

//if (ietab)
//dump('updateToolbarForCurrentTab(ietab) / '+ietab.title+' / '+ietab.url+'\n');

				if (this.mTotalProgress &&
					this.mTotalProgress < 1) {
					this.progressmeter.removeAttribute('collapsed');
					this.progressmeter.setAttribute('mode', 'normal');
					this.progressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));

					this.urlbarProgressmeter.removeAttribute('collapsed');
					this.urlbarProgressmeter.setAttribute('mode', 'normal');
					this.urlbarProgressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));
				}
				else {
					this.progressmeter.setAttribute('collapsed', true);
					this.urlbarProgressmeter.setAttribute('collapsed', true);
				}

				if (!isBusy) {
					this.stopButton.setAttribute('disabled', true);
					this.reloadButton.removeAttribute('disabled');

					if (t) {
						this.setIcon(t.getAttribute('image'));
					}
					else if (!this.mIconURL) {
						this.useDefaultIcon();
					}

					this.mIsBusy = false;
					this.removeAttribute('busy');

					try {
						if (b.canGoBack)
							this.backButton.removeAttribute('disabled');
						else
							this.backButton.setAttribute('disabled', true);

						if (b.canGoForward)
							this.forwardButton.removeAttribute('disabled');
						else
							this.forwardButton.setAttribute('disabled', true);
					}
					catch(e) {
						this.backButton.setAttribute('disabled', true);
						this.forwardButton.setAttribute('disabled', true);
					}

					var title = (ietab ? ietab.title : b.contentDocument.title ) || this.title.getAttribute('blank-label');
					this.title.setAttribute('value', title);
					while (this.vTitle.hasChildNodes())
						this.vTitle.removeChild(this.vTitle.firstChild);
					this.vTitle.appendChild(document.createTextNode(
						title.replace(/(.)/g, '$1\n')
							.replace(/:/g, '..')
							.replace(/;/g, ',.')
							.replace(/[(\[\{<\uff1c\uff08\u300c\uff5b\u3014\u300e\u3008\u300a\u3010\uff3b\u226a]/g, '\u2227')
							.replace(/[)\]\}>\uff1e\uff09\u300d\uff5d\u3015\u300f\u3009\u300b\u3011\uff3d\u226b]/g, '\u2228')
							.replace(/\|/g, '<->')
							.replace(/^[-\u2015\u30fc\uff0d\uff70]$/mg, '|')
							.replace(/<->/mg, '--')
					));
					this.setAttribute('tooltiptext', title);
					this.updateIcon();
				}
				else {
					this.stopButton.removeAttribute('disabled');
					this.reloadButton.setAttribute('disabled', true);

					this.mIsBusy = true;
					this.setAttribute('busy', true);
					var title = this.title.getAttribute('loading-label');
					this.title.setAttribute('value', title);
					while (this.vTitle.hasChildNodes())
						this.vTitle.removeChild(this.vTitle.firstChild);
					this.vTitle.appendChild(document.createTextNode(
						title.replace(/(.)/g, '$1\n')
							.replace(/:/g, '..')
							.replace(/;/g, ',.')
							.replace(/[(\[\{<\uff1c\uff08\u300c\uff5b\u3014\u300e\u3008\u300a\u3010\uff3b\u226a]/g, '\u2227')
							.replace(/[)\]\}>\uff1e\uff09\u300d\uff5d\u3015\u300f\u3009\u300b\u3011\uff3d\u226b]/g, '\u2228')
							.replace(/\|/g, '<->')
							.replace(/^[-\u2015\u30fc\uff0d\uff70]$/mg, '|')
							.replace(/<->/mg, '--')
					));
					this.setAttribute('tooltiptext', title);
					this.updateIcon();
				}


				if (ietab && ietab.url) {
					this.urlbar.value = (/^file:\/\/.*/.test(ietab.url) ? encodeURI(gIeTab.convertToUTF8(ietab.url)) : ietab.url );
					if (this.urlbar.value.indexOf(gIeTabChromeStr) == 0)
						this.urlbar.value = this.urlbar.value.substring(gIeTabChromeStr.length);
				}
				else if (aSwitchTab) {
					this.urlbar.value = b.currentURI.spec;
				}

			]]></body>
		</method>



		<method name="toggleNavigation">
			<parameter name="aShow"/>
			<body><![CDATA[
				this.toolbarDeck.setAttribute('selectedIndex', aShow ? '1' : '0' );
				if (this.mToggleNavigationOnHoverTimer) {
					window.clearTimeout(this.mToggleNavigationOnHoverTimer);
					this.mToggleNavigationOnHoverTimer = null;
				}
			]]></body>
		</method>

		<method name="toggleNavigationOnHover">
			<parameter name="aShow"/>
			<parameter name="aForce"/>
			<parameter name="aDelay"/>
			<body><![CDATA[
				if (
					this.getAttribute('toolbar-navigation') == 'true' ||
					(
						this.isUrlbarFocused &&
						!aShow
					)
					) return;

				if (this.contentCollapsed) aShow = false;

				if (this.mIsToolbarHover == aShow) {
					if (!aShow && this.mToggleNavigationOnHoverTimer) {
						window.clearTimeout(this.mToggleNavigationOnHoverTimer);
						this.mToggleNavigationOnHoverTimer = null;
					}
					return;
				}

				this.mIsToolbarHover = aShow;

				if (aForce && aDelay === void(0)) {
					this.toggleNavigation(aShow);
					return;
				}

				this.mToggleNavigationOnHoverTimer = window.setTimeout(
					function(aShowFlag, aThis) {
						if (aShowFlag == aThis.mIsToolbarHover &&
							aThis.toolbarDeck)
							aThis.toggleNavigation(aShowFlag);
						aThis.mToggleNavigationOnHoverTimer = null;
					},
					(
						aDelay !== void(0) ? aDelay :
							this.mIsToolbarHover ?
								SplitBrowser.subBrowserToolbarShowDelay :
								SplitBrowser.subBrowserToolbarHideDelay
					),
					aShow,
					this
				);
			]]></body>
		</method>
		<field name="mToggleNavigationOnHoverTimer">null</field>

		<method name="resetNavigation">
			<body><![CDATA[
				if (this.getAttribute('toolbar-navigation') != 'true')
					this.toggleNavigation(false);
			]]></body>
		</method>





		<method name="setIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				this.mIconURL = aURI;
				this.updateIcon();
			]]></body>
		</method>

		<method name="updateIcon">
			<body><![CDATA[
				if (!this.mIsBusy && this.mIconURL) {
					this.favicon.setAttribute('src', this.mIconURL);
					this.vFavicon.setAttribute('src', this.mIconURL);
					this.urlbarFavicon.setAttribute('src', this.mIconURL);
				}
				else {
					this.favicon.removeAttribute('src');
					this.vFavicon.removeAttribute('src');
					this.urlbarFavicon.removeAttribute('src');
				}
			]]></body>
		</method>

		<method name="useDefaultIcon">
			<body><![CDATA[
				if (this.browser.contentDocument instanceof ImageDocument) {
					if (SplitBrowser.getPref('browser.chrome.site_icons')) {
						try {
							var sz = SplitBrowser.getPref('browser.chrome.image_icons.max_size');
							if (!sz)
								return;
							var req = this.browser.contentDocument.imageRequest;
							if (!req || !req.image || req.image.width > sz || req.image.height > sz)
								return;
							this.setIcon(this.browser.currentURI.spec);
						}
						catch (e) {
						}
					}
				}
				else if (this.shouldLoadFavIcon(this.browser.currentURI)) {
					var url = this.browser.currentURI.prePath + '/favicon.ico';
					if (!this.isIconKnownMissing(url))
						this.setIcon(url);
				}
			]]></body>
		</method>

		<method name="shouldLoadFavIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				return (
					aURI &&
					SplitBrowser.getPref('browser.chrome.site_icons') &&
					SplitBrowser.getPref('browser.chrome.favicons') &&
					('schemeIs' in aURI) &&
					(aURI.schemeIs('http') || aURI.schemeIs('https'))
				);
			]]></body>
		</method>

		<method name="addToMissedIconCache">
			<parameter name="aURI"/>
			<body><![CDATA[
				var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);
				if (!entry) return;

				if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)
					entry.setMetaDataElement('Icon', 'Missed');
				entry.markValid();
				entry.close();
			]]></body>
		</method>

		<method name="openCacheEntry">
			<parameter name="aKey"/>
			<parameter name="aAccess"/>
			<body><![CDATA[
				try {
					if (!this.mMissedIconCache) {
						var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);
						this.mMissedIconCache = cacheService.createSession('MissedIconCache', Components.interfaces.nsICache.STORE_ANYWHERE, true);
						if (!this.mMissedIconCache) return null;
					}
					return this.mMissedIconCache.openCacheEntry(aKey, aAccess, true);
				}
				catch (e) {
					return null;
				}
			]]></body>
		</method>

		<method name="isIconKnownMissing">
			<parameter name="aKey"/>
			<body><![CDATA[
				var e = this.openCacheEntry(aKey, Components.interfaces.nsICache.ACCESS_READ);
				if (e) {
					e.close();
					return true;
				}
				return false;
			]]></body>
		</method>

		<method name="onLinkAdded">
			<parameter name="aEvent"/>
			<body><![CDATA[
				if (!SplitBrowser.getPref('browser.chrome.site_icons')) return;
				if (!aEvent.originalTarget.rel.match((/(?:^|\s)icon(?:\s|$)/i))) return;

				var href = aEvent.originalTarget.href;
				if (!href) return;

				const nsIContentPolicy = Components.interfaces.nsIContentPolicy;
				try {
					var contentPolicy = Components.classes['@mozilla.org/layout/content-policy;1'].getService(nsIContentPolicy);
				}
				catch(e) {
					return;
				}

				const secMan = Components.classes['@mozilla.org/scriptsecuritymanager;1'].getService(Components.interfaces.nsIScriptSecurityManager);
				const ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);
				const targetDoc = aEvent.target.ownerDocument;
				var uri = ioService.newURI(href, targetDoc.characterSet, null);
				var origURI = ioService.newURI(targetDoc.documentURI, targetDoc.characterSet, null);

				const nsIScriptSecMan = Components.interfaces.nsIScriptSecurityManager;
				try {
					const aboutNeterr = 'about:neterror?';
					if (origURI.spec.substr(0, aboutNeterr.length) != aboutNeterr ||
						!uri.schemeIs('chrome'))
						secMan.checkLoadURI(origURI, uri, nsIScriptSecMan.DISALLOW_SCRIPT);
				}
				catch(e) {
					return;
				}

				if (contentPolicy.shouldLoad(
						nsIContentPolicy.TYPE_IMAGE,
						uri,
						origURI,
						aEvent.target,
						aEvent.target.type,
						null
					) != nsIContentPolicy.ACCEPT)
					return;

				if (targetDoc == this.browser.contentDocument)
					this.setIcon(href);
			]]></body>
		</method>



		<field name="pageDNDObserver"><![CDATA[
		({
			mOwner : this,

			onDragStart : function (aEvent, aXferData, aDragAction)
			{
				var value = this.mOwner.src;
				if (!value) return;

				var urlString = value + '\n' + this.mOwner.browser.contentDocument.title;
				var htmlString = '<a href="' + value + '">' + value + '</a>';

				aXferData.data = new TransferData();

				aXferData.data.addDataForFlavour('application/x-moz-splitbrowser',
					'subbrowser\n'+
					{
						id     : this.mOwner.id,
						uri    : value,
						width  : this.mOwner.boxObject.width,
						height : this.mOwner.boxObject.height
					}.toSource()
				);

				aXferData.data.addDataForFlavour('text/x-moz-url', urlString);
				aXferData.data.addDataForFlavour('text/unicode', value);
				aXferData.data.addDataForFlavour('text/plain', value);
				aXferData.data.addDataForFlavour('text/html', htmlString);

				aDragAction.action =
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_COPY |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_MOVE |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_LINK;
			},

			onDragOver : function(aEvent, aFlavour, aDragSession) {
			},

			onDrop : function (aEvent, aXferData, aDragSession)
			{
				aEvent.preventDefault();
				aEvent.stopPropagation();

				var uri = SplitBrowser.getURIFromDragData(aXferData, aDragSession, aEvent);
				if (!uri) return;

				// fallback for Linux
				// in Linux, "dragdrop" event doesn't fire on the button.
				var forceCheck = aEvent.ctrlKey || aXferData.flavour.contentType == 'application/x-moz-splitbrowser';
				var check = this.mOwner.checkEventFiredOnEdge(aEvent, forceCheck);
				if (!check) return;

				if (
					( // events on the tab bar should be handled by tabbrowser's "_onDrop" method
						aXferData.flavour.contentType == 'application/x-moz-splitbrowser' &&
						SplitBrowser.isEventFiredOnTabbar(aEvent)
					) ||
					( // ignore self-drop onto the toolbar
						SplitBrowser.getSubBrowserFromChild(aDragSession.sourceNode) == this.mOwner &&
						this.mOwner.isEventFiredOnToolbar(aEvent)
					)
					) {
					return;
				}

				if (
					(forceCheck || SplitBrowser.isLinux) &&
					SplitBrowser.addButton.targetSubBrowser == this.mOwner &&
					(
						check.isTop ||
						check.isBottom ||
						check.isLeft ||
						check.isRight
					) &&
					(
						this.mOwner.browser.localName != 'tabbrowser' ||
						!this.mOwner.isEventFiredOnToolbar(aEvent)
					)
					) {
					var tab = SplitBrowser.getTabFromChild(aDragSession.sourceNode);
					var tabbrowser = SplitBrowser.getTabBrowserFromChild(tab);
					if (!tabbrowser) tab = null;
					SplitBrowser.fireSubBrowserAddRequestEventFromButton(
						tab || uri,
						SplitBrowser.isAccelKeyPressed(aEvent)
					);
					return;
				}

				if (SplitBrowser.performDropOnTabBrowser(arguments, this.mOwner.browser)) {
					return;
				}

				if (this.mOwner.browser.localName == 'tabbrowser' &&
					this.mOwner.isEventFiredOnToolbar(aEvent)) {
					this.mOwner.browser.selectedTab = this.mOwner.browser.addTab(uri);
					return;
				}

				this.mOwner.load(uri);
			},

			getSupportedFlavours : function ()
			{
				var flavourSet = new FlavourSet();
				flavourSet.appendFlavour('application/x-moz-splitbrowser');
				flavourSet.appendFlavour('application/x-moz-tabbrowser-tab');
				flavourSet.appendFlavour('text/x-moz-text-internal');
				flavourSet.appendFlavour('text/x-moz-url');
				flavourSet.appendFlavour('text/unicode');
				flavourSet.appendFlavour('text/plain');
				flavourSet.appendFlavour('application/x-moz-file', 'nsIFile');
				return flavourSet;
			}
		})
		]]></field>
		<method name="isEventFiredOnToolbar">
			<parameter name="aEvent"/>
			<body><![CDATA[
				var box = this.toolbar.boxObject;
				return (
					box.screenX <= aEvent.screenX &&
					box.screenX + box.width >= aEvent.screenX &&
					box.screenY <= aEvent.screenY &&
					box.screenY + box.height >= aEvent.screenY
					);
			]]></body>
		</method>


		<method name="openNewTab">
			<body><![CDATA[
				var b = this.browser;
				var t = b.addTab('about:blank');
				this.toggleNavigation(true);
				window.setTimeout(function(aUrlbar) {
					b.selectedTab = t;
					window.setTimeout(function(aUrlbar) {
						aUrlbar.value = '';
						aUrlbar.focus();
					}, 0, aUrlbar);
				}, 0, this.urlbar);
			]]></body>
		</method>

		<method name="newUpdateCurrentBrowser">
			<body><![CDATA[
				var result = this.__splitbrowser__updateCurrentBrowser.apply(this, arguments);

				if (this.parentSubBrowser.focused) {
					SplitBrowser.mainBrowserBox.blur();
				}
				else {
					var node = SplitBrowser.activeSubBrowser;
					this.parentSubBrowser.blur();
					if (node)
						node.focus();
				}

				return result;
			]]></body>
		</method>

		<method name="addProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;
				if (browser.__splitbrowser__tabProgressListener) return;

				var filter = Components.classes['@mozilla.org/appshell/component/browser-status-filter;1'].createInstance(Components.interfaces.nsIWebProgress);
				var listener = this.createProgressListener(aTab, browser);
				filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
				browser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);

				browser.__splitbrowser__tabProgressListener = listener;
				browser.__splitbrowser__tabProgressFilter = filter;
			]]></body>
		</method>

		<method name="removeProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;
				if (!browser.__splitbrowser__tabProgressListener) return;

				delete browser.__splitbrowser__tabProgressListener.mOwner;
				delete browser.__splitbrowser__tabProgressListener.mTab;
				delete browser.__splitbrowser__tabProgressListener.mBrowser;

				browser.webProgress.removeProgressListener(browser.__splitbrowser__tabProgressFilter);
				browser.__splitbrowser__tabProgressFilter.removeProgressListener(browser.__splitbrowser__tabProgressListener);

				delete browser.__splitbrowser__tabProgressListener;
				delete browser.__splitbrowser__tabProgressFilter;
			]]></body>
		</method>

		<method name="createProgressListener">
			<parameter name="aTab"/>
			<parameter name="aBrowser"/>
			<body><![CDATA[
			return {

			mOwner         : this,
			mTab           : aTab,
			mBrowser       : aBrowser,
			mTotalProgress : 0,

			onProgressChange: function (aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress)
			{
				if (this.mOwner.isIeTab) {
					var ietab = this.mOwner.getIETabOf(this.mBrowser);
					aCurTotalProgress = ietab.progress;
					aMaxTotalProgress = (aCurTotalProgress == -1 ? -1 : 100);
				}

				this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
				if (this.mTab)
					this.mTab.mSubbrowserTabTotalProgress = this.mTotalProgress;

				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.mTotalProgress = this.mTotalProgress;
				this.mOwner.updateToolbarForCurrentTab();
			},

			onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
				if (
					aStateFlags & nsIWebProgressListener.STATE_START &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = true;
					this.mOwner.updateToolbarForCurrentTab();
				}
				else if (
					aStateFlags & nsIWebProgressListener.STATE_STOP &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = false;
					this.mOwner.updateToolbarForCurrentTab();
				}
			},

			onLocationChange : function(aWebProgress, aRequest, aLocation)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.urlbar.value = aLocation.spec;
				this.mOwner.setAttribute('src', aLocation.spec);

				if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
					aWebProgress.isLoadingDocument)
					this.mOwner.setIcon(null);
			},

			onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
			{
			},

			onSecurityChange : function(aWebProgress, aRequest, aState)
			{
			},

			QueryInterface : function(aIID)
			{
				if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
					aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
					aIID.equals(Components.interfaces.nsISupports))
					return this;
				throw Components.results.NS_NOINTERFACE;
			}

			};
			]]></body>
		</method>

		<constructor><![CDATA[
			var b = this.browser;
			if (b.nextSibling && b.nextSibling.localName == 'browser')
				b.parentNode.removeChild(b.nextSibling);
			if (b.previousSibling && b.previousSibling.localName == 'tabbrowser')
				b.parentNode.removeChild(b.previousSibling);

			b.parentSubBrowser = this;

			if (SplitBrowser.getPref('splitbrowser.show.toolbar.navigation.always')) {
				this.setAttribute('toolbar-navigation', true);
				this.toggleNavigation(true);
			}

			if (b.localName == 'tabbrowser') {
				eval('b.addTab = '+
					b.addTab.toSource().replace(
						'if (!this.mTabChangedListenerAdded) {',
						'$& this.attrChangedListener = attrChanged;'
					)
				);
				b.__splitbrowser__updateCurrentBrowser = b.updateCurrentBrowser;
				b.updateCurrentBrowser = this.newUpdateCurrentBrowser;

				SplitBrowser.updateTabBrowser(b);

				window.setTimeout(this.mDelayedTabbrowserStartup, 0, this);
			}
			else {
				this.addProgressListener(null);

				window.setTimeout(this.mDelayedBrowserStartup, 0, this);

				if (this.getAttribute('src'))
					this.load(this.getAttribute('src'));
			}

			var os = Components.classes['@mozilla.org/observer-service;1']
						.getService(Components.interfaces.nsIObserverService);
			os.addObserver(this.syncScrollObserver, 'subbrowser:syncScroll', false);
		]]></constructor>
		<destructor><![CDATA[
			var os = Components.classes['@mozilla.org/observer-service;1']
						.getService(Components.interfaces.nsIObserverService);
			os.removeObserver(this.syncScrollObserver, 'subbrowser:syncScroll');
		]]></destructor>

		<method name="mDelayedBrowserStartup">
			<parameter name="aThis"/>
			<body><![CDATA[
				aThis.blur();
				aThis.mUpdateToolbarMode();

				var newEvent = document.createEvent('Events');
				newEvent.initEvent('SubBrowserAdded', false, true);
				aThis.dispatchEvent(newEvent);
			]]></body>
		</method>
		<method name="mDelayedTabbrowserStartup">
			<parameter name="aThis"/>
			<body><![CDATA[
			aThis.mDelayedBrowserStartup(aThis);

			var b = aThis.browser;
			var t = SplitBrowser.getFirstTab(b);
			aThis.addProgressListener(t);

			var autoHide = SplitBrowser.getPref('splitbrowser.tabs.autoHide');
			if (b.mTabs.length == 1)
				b.setStripVisibilityTo(!autoHide);

			b = b.getBrowserForTab(t);
			b.webNavigation.sessionHistory = Components.classes['@mozilla.org/browser/shistory;1'].createInstance(Components.interfaces.nsISHistory);

			var os = Components.classes['@mozilla.org/observer-service;1'].getService(Components.interfaces.nsIObserverService);
			os.addObserver(b, 'browser:purge-session-history', false);
			b.removeAttribute('disablehistory');
			b.docShell.QueryInterface(Components.interfaces.nsIDocShellHistory).useGlobalHistory = true;

			if (aThis.getAttribute('src'))
				aThis.load(aThis.getAttribute('src'));
			]]></body>
		</method>


		<method name="destroy">
			<body><![CDATA[
				if (this.focused) {
					gBrowser.contentWindow.focus();
				}
				this.blur();

				var b = this.browser;
				if (b.localName == 'tabbrowser') {
					if (b.mCurrentBrowser.getAttribute('type') == 'content-primary')
						document.getElementById('appcontent').contentWrapper.focus();

					b.mCurrentBrowser.removeAttribute('type');
					b.mCurrentBrowser.setAttribute('type', 'content');
					var tabs = SplitBrowser.getTabs(b);
					for (var i = 0, maxi = tabs.snapshotLength; i < maxi; i++)
					{
						this.removeProgressListener(tabs.snapshotItem(i));
						try {
							b.browsers[i].destroy();
							b.browsers[i].removeEventListener('DOMTitleChanged', b.onTitleChanged, true);
						}
						catch(e) {
						}
					}
					try {
						document.removeEventListener('keypress', b._keyEventHandler, false);
						if (b.attrChangedListener)
							b.mTabBox.addEventListener('DOMAttrModified', b.attrChangedListener, false);
						window.removeEventListener('resize', b, false);
					}
					catch(e) {
					}
					try {
						window.removeEventListener('resize', b.mTabContainer, false);
						b.mStrip.removeEventListener('overflow', b.mTabContainer, false);
						b.mStrip.removeEventListener('underflow', b.mTabContainer, false);
					}
					catch(e) {
					}
				}
				else {
					if (b.getAttribute('type') == 'content-primary')
						document.getElementById('appcontent').contentWrapper.focus();

					b.removeAttribute('type');
					b.setAttribute('type', 'content');
					this.removeProgressListener();

					try {
						b.destroy();
					}
					catch(e) {
					}
				}

				var newEvent = document.createEvent('Events');
				newEvent.initEvent('SubBrowserRemoved', false, true);
				document.documentElement.dispatchEvent(newEvent);

				b.parentSubBrowser = null;

				b.parentNode.removeChild(b);
			]]></body>
		</method>


		<method name="onTabSelect">
			<parameter name="aEvent"/>
			<body><![CDATA[
				this.updateToolbarForCurrentTab(true);

				var newEvent = document.createEvent('Events');
				newEvent.initEvent('SubBrowserTabSelect', false, true);
				newEvent.targetTab = this.browser.selectedTab;
				this.dispatchEvent(newEvent);
			]]></body>
		</method>

		<method name="onTabOpen">
			<parameter name="aEvent"/>
			<body><![CDATA[
				this.addProgressListener(aEvent.originalTarget);
			]]></body>
		</method>

		<method name="onTabClose">
			<parameter name="aEvent"/>
			<body><![CDATA[
				this.removeProgressListener(aEvent.originalTarget);
				if (SplitBrowser.getTabs(this.browser).snapshotLength <= 2) {
					this.browser.setStripVisibilityTo(!SplitBrowser.getPref('splitbrowser.tabs.autoHide'));
				}
			]]></body>
		</method>

		<method name="mUpdateToolbarMode">
			<body><![CDATA[
				var c = this.flexibleParent;
				while (c && c.parentNode && !c.splitterDragging)
					c = c.parentNode;
				if (c && c == document) c = null;

				var collapse;

				var toolbarShown = SplitBrowser.getPref('splitbrowser.show.toolbar.always');

				if (this.boxObject.width <= this.minSize) {
					if (this.boxObject.height <= this.minSize) {
						this.setAttribute('toolbar-mode', 'horizontal');
						if (c && toolbarShown) c.setAttribute('maxheight', 0);
					}
					else {
						this.setAttribute('toolbar-mode', 'vertical');
						if (c && toolbarShown) c.setAttribute('maxwidth', 0);
					}
					collapse = true;
				}
				else {
					this.setAttribute('toolbar-mode', 'horizontal');
					if (this.boxObject.height <= this.minSize) {
						if (c && toolbarShown) c.setAttribute('maxheight', 0);
						collapse = true;
					}
					else {
						collapse = false;
					}
				}

				if (collapse) {
					if (!this.contentCollapsed)
						this.collapse();

					this.setAttribute('content-collapsed', 'true');
					if (this.getAttribute('toolbar-navigation') == 'true')
						this.toggleNavigation(false);

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserContentCollapsed', false, true);
					document.documentElement.dispatchEvent(newEvent);
				}
				else {
					this.removeAttribute('content-collapsed');
					if (this.getAttribute('toolbar-navigation') == 'true')
						this.toggleNavigation(true);

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserContentExpanded', false, true);
					document.documentElement.dispatchEvent(newEvent);
				}
			]]></body>
		</method>

	</implementation>

	<handlers>
		<handler event="DOMLinkAdded" phase="capturing"
			action="this.onLinkAdded(event);"/>

		<handler event="resize"
			action="this.mUpdateToolbarMode();"/>

		<handler event="click"
			action="if (!this.contentCollapsed &amp;&amp; !this.focused) this.browser.contentWindow.focus();"/>

		<handler event="DOMWindowClose" phase="capturing"><![CDATA[
			if (
				(
					this.browser.localName != 'tabbrowser' ||
					this.browser.browsers.length == 1
				) &&
				event.target == this.browser.contentWindow
				) {
				event.preventDefault();
				this.close();
			}
		]]></handler>

		<handler event="blur" phase="capturing"><![CDATA[
			if (event.originalTarget.ownerDocument == document &&
				event.originalTarget.localName == 'input') {
				this.isUrlbarFocused = false;
				this.toggleNavigationOnHover(false);
			}
		]]></handler>

		<handler event="TabSelect" action="this.onTabSelect(event);"/>
		<handler event="TabOpen" action="this.onTabOpen(event);"/>
		<handler event="TabClose" action="this.onTabClose(event);"/>

	</handlers>
</binding>


</bindings>
