<?xml version="1.0"?>

<!DOCTYPE overlay [
	<!ENTITY % mainDTD SYSTEM "chrome://splitbrowser/locale/" >
	%mainDTD;
]>

<bindings id="splitbrowserBindings"
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
	xmlns:xbl="http://www.mozilla.org/xbl">

<binding id="contents-in-container" extends="xul:vbox">
	<implementation>
		<property name="parentContainer" readonly="true">
			<getter><![CDATA[
				var container = this.parentNode;
				while (container.localName != 'subbrowser-container' &&
						container.parentNode)
				{
					container = container.parentNode;
				}

				return (container.localName == 'subbrowser-container') ? container : null ;
			]]></getter>
		</property>

		<property name="parentOrient" readonly="true">
			<getter><![CDATA[
				var node = this.parentContainer;
				if (!node) return null;

				node = node.parentNode;

				if (node.orient == 'horizontal' || node.localName == 'hbox')
					return 'horizontal';
				else
					return 'vertical';
			]]></getter>
		</property>
	</implementation>
</binding>



<binding id="container" extends="#contents-in-container">
	<!--content orient="vertical">
		<xul:vbox anonid="vertical-container" flex="1"
			class="vertical-container">
			<xul:hbox anonid="horizontal-container" flex="1"
				class="horizontal-container"/>
		</xul:vbox>
	</content-->

	<implementation>
<!--
		<field name="hContainer">null</field>
		<field name="vContainer">null</field>
-->
		<constructor><![CDATA[
			if (
				this.vContainer ||
				this.localName != 'subbrowser-container' ||
				(
					this.hasChildNodes() &&
					this.firstChild.getAttribute('class') == 'vertical-container'
				)
				)
				return;

			this.vContainer = document.createElement('vbox');
			this.vContainer.setAttribute('class', 'vertical-container');
			this.vContainer.setAttribute('flex', 1);
			this.appendChild(this.vContainer);

			this.hContainer = document.createElement('hbox');
			this.hContainer.setAttribute('class', 'horizontal-container');
			this.hContainer.setAttribute('flex', 1);
			this.vContainer.appendChild(this.hContainer);

		]]></constructor>

		<method name="toggleCollapsed">
			<body><![CDATA[
				if (!this.isCollapsed()) {
					this.lastWidth  = this.boxObject.width;
					this.lastHeight = this.boxObject.height;
					this.collapsed  = true;
				}
				else {
					this.collapsed  = false;
					this.width      = this.lastWidth;
					this.height     = this.lastHeight;
				}
			]]></body>
		</method>
		<method name="isCollapsed">
			<body><![CDATA[
				return this.collapsed || !this.boxObject.width || !this.boxObject.height;
			]]></body>
		</method>
		<field name="lastWidth">-1</field>
		<field name="lastHeight">-1</field>
	</implementation>

	<handlers>
		<handler event="mousedown"><![CDATA[
			var newEvent = document.createEvent('Events');
			newEvent.force = true;
			newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
			this.dispatchEvent(newEvent);
		]]></handler>
	</handlers>
</binding>

<binding id="toplevel-container" extends="#container">
	<content orient="vertical">
		<xul:vbox anonid="vertical-container" flex="1"
			class="vertical-container">
			<xul:hbox anonid="horizontal-container" flex="1"
				class="horizontal-container">
				<xul:vbox anonid="primary-browser-wrapper" flex="1"
					class="primary-browser-wrapper">
					<children/>
				</xul:vbox>
			</xul:hbox>
		</xul:vbox>
	</content>

	<implementation>
		<property name="hContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'horizontal-container'); } catch(e) { return null; }"/>
		<property name="vContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-container'); } catch(e) { return null; }"/>
		<property name="contentWrapper" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'primary-browser-wrapper'); } catch(e) { return null; }"/>
	</implementation>
</binding>



<binding id="subbrowser-base" extends="#contents-in-container">
	<implementation>
		<property name="rightOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxY > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="bottomOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxX > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="contentAreaSizeObject" readonly="true">
			<getter><![CDATA[
				var box, retVal;
				if (this.localName == 'subbrowser') {
					if (this.browser.localName == 'tabbrowser')
						box = this.browser.mCurrentBrowser;
					else
						box = this.browser;
				}
				else
					box = gBrowser.mCurrentBrowser;

				retVal =  { box : box };

				box = box.boxObject;
				retVal.x       = box.x;
				retVal.y       = box.y;
				retVal.screenX = box.screenX;
				retVal.screenY = box.screenY;
				retVal.width   = box.width - this.rightOffset;
				retVal.height  = box.height - this.bottomOffset;

				retVal.middleX = parseInt(box.x + (box.width / 2));
				retVal.middleY = parseInt(box.y + (box.height / 2));
				retVal.middleScreenX = parseInt(box.screenX + (box.width / 2));
				retVal.middleScreenY = parseInt(box.screenY + (box.height / 2));

				retVal.areaWidth   = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.width * 0.6));
				retVal.areaX       = retVal.middleX - parseInt(retVal.areaWidth / 2);
				retVal.areaScreenX = retVal.middleScreenX - parseInt(retVal.areaWidth / 2);
				retVal.areaHeight  = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.height * 0.6));
				retVal.areaY       = retVal.middleY - parseInt(retVal.areaHeight / 2);
				retVal.areaScreenY = retVal.middleScreenY - parseInt(retVal.areaHeight / 2);

				return retVal;
			]]></getter>
		</property>

		<property name="src" readonly="true"
			onget="return gBrowser.currentURI.spec;"/>

		<method name="checkEventFiredOnEdge">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<body><![CDATA[
				var offset   = SplitBrowser.addButtonSize;
				var box      = this.contentAreaSizeObject;

				if (aForceFire || aEvent.ctrlKey) {
					var pos = SplitBrowser.getDropPositionOnContentArea(aEvent, box.box);
					return {
						isTop    : pos == SplitBrowser.POSITION_TOP,
						isBottom : pos == SplitBrowser.POSITION_BOTTOM,
						isLeft   : pos == SplitBrowser.POSITION_LEFT,
						isRight  : pos == SplitBrowser.POSITION_RIGHT
					};
				}

				var isTop    = (aEvent.screenY >= box.screenY &&
								aEvent.screenY < box.screenY+offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isBottom = (aEvent.screenY <= box.screenY+box.height &&
								aEvent.screenY > box.screenY+box.height-offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isLeft   = (aEvent.screenX >= box.screenX &&
								aEvent.screenX < box.screenX+offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);
				var isRight  = (aEvent.screenX <= box.screenX+box.width &&
								aEvent.screenX > box.screenX+box.width-offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);

				return {
					isTop    : isTop,
					isBottom : isBottom,
					isLeft   : isLeft,
					isRight  : isRight
				};
			]]></body>
		</method>

		<method name="handleMouseOverEvent">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<body><![CDATA[
				var check = this.checkEventFiredOnEdge(aEvent, aForceFire);
				if (
					check.isTop ||
					check.isBottom ||
					check.isLeft ||
					check.isRight
					) {
					if (
						(check.isTop && !this.mIsMouseOverTop) ||
						(check.isBottom && !this.mIsMouseOverBottom) ||
						(check.isLeft && !this.mIsMouseOverLeft) ||
						(check.isRight && !this.mIsMouseOverRight)
						) {
						this.mIsMouseOverTop    = check.isTop;
						this.mIsMouseOverBottom = check.isBottom;
						this.mIsMouseOverLeft   = check.isLeft;
						this.mIsMouseOverRight  = check.isRight;

						var newEvent = document.createEvent('Events');
						newEvent.initEvent('SubBrowserEnterContentAreaEdge', false, true);
						newEvent.isTop    = check.isTop;
						newEvent.isBottom = check.isBottom;
						newEvent.isLeft   = check.isLeft;
						newEvent.isRight  = check.isRight;
						newEvent.targetSubBrowser = this;
						newEvent.firedBy = aEvent.type;
						this.dispatchEvent(newEvent);
					}
				}
				else {
					this.mIsMouseOverTop    = false;
					this.mIsMouseOverBottom = false;
					this.mIsMouseOverLeft   = false;
					this.mIsMouseOverRight  = false;

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
					this.dispatchEvent(newEvent);
				}
			]]></body>
		</method>

		<method name="handleDragOverEvent">
			<parameter name="aEvent"/>
			<body><![CDATA[
				const DragService = Components.classes['@mozilla.org/widget/dragservice;1'].getService(Components.interfaces.nsIDragService);
				var session = DragService.getCurrentSession();
				if (!session) return;

				var isSubBrowser = session.isDataFlavorSupported('application/x-moz-splitbrowser');
				if (isSubBrowser ||
					session.isDataFlavorSupported('text/x-moz-url') ||
					session.isDataFlavorSupported('text/unicode') ||
					session.isDataFlavorSupported('application/x-moz-file')) {
					this.handleMouseOverEvent(aEvent, isSubBrowser);
					var check = this.checkEventFiredOnEdge(aEvent, isSubBrowser);
					if (
						SplitBrowser.isLinux &&
						SplitBrowser.addButton.targetBrowser == this &&
						(
							check.isTop ||
							check.isBottom ||
							check.isLeft ||
							check.isRight
						)
						) {
						session.canDrop = true;
					}
				}
			]]></body>
		</method>

	</implementation>

	<handlers>
		<handler event="mousemove"
			action="if (nsPreferences.getBoolPref('splitbrowser.show.addbuttons.hover')) this.handleMouseOverEvent(event); return true;"/>

		<handler event="dragover" phase="capturing"
			action="if (nsPreferences.getBoolPref('splitbrowser.show.addbuttons.dragdrop')) this.handleDragOverEvent(event); return true;"/>
	</handlers>
</binding>

<binding id="subbrowser" extends="#subbrowser-base">
	<content orient="vertical"
		context="_child">
		<xul:menupopup anonid="contextmenu"
			onpopupshowing="
				this.parentNode.toggleToolbar(false, true, 0);
				this.parentNode.updateContextMenu(event);
			"
			oncommand="this.parentNode.toggleToolbar(false, true, 0);"
			ondraggesture="event.stopPropagation();">
			<xul:menuitem class="subbrowser-context-close"
				label="&splitbrowser.subbrowser.menu.close;"
				oncommand="this.parentNode.parentNode.close();"/>
			<xul:menuitem class="subbrowser-context-collapse"
				label="&splitbrowser.subbrowser.menu.collapse;"
				oncommand="this.parentNode.parentNode.toggleCollapsed();"/>
			<xul:menuitem class="subbrowser-context-expand"
				label="&splitbrowser.subbrowser.menu.expand;"
				oncommand="this.parentNode.parentNode.toggleCollapsed();"/>
			<xul:menuseparator/>
			<xul:menuitem class="subbrowser-context-openNewTab"
				label="&splitbrowser.subbrowser.menu.openNewTab;"
				oncommand="this.parentNode.parentNode.openNewTab();"/>
		</xul:menupopup>
		<xul:hbox flex="1">
			<xul:toolbox anonid="subbrowser-toolbox-vertical"
				orient="vertical"
				class="subbrowser-toolbox subbrowser-toolbox-vertical">
			<xul:toolbar anonid="subbrowser-toolbar-vertical"
				orient="vertical"
				flex="1"
				class="subbrowser-toolbar subbrowser-toolbar-vertical chromeclass-extrachrome"
				align="center"
			 	ondraggesture="
			 		nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.pageDNDObserver);
			 	"
				ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.pageDNDObserver);"
				ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode.pageDNDObserver);">
				<xul:toolbarbutton
					anonid="close-button-vertical"
					class="tabs-closebutton toolbarbutton-1 chromeclass-toolbar-additional"
					tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
					oncommand="this.parentNode.parentNode.parentNode.parentNode.close();"/>
				<xul:box class="subbrowser-toolbar-item favicon-box">
					<xul:image class="subbrowser-toolbar-item favicon"
						anonid="vertical-favicon"
						validate="never"
						ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
						onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
				</xul:box>
				<!--xul:label anonid="title"
					blank-label="&splitbrowser.subbrowser.blank;"
					loading-label="&splitbrowser.subbrowser.loading;"
					flex="1"
					crop="end"/-->
			</xul:toolbar>
			</xul:toolbox>
			<xul:vbox flex="1">
				<xul:toolbox anonid="subbrowser-toolbox-horizontal"
					orient="horizontal"
					class="subbrowser-toolbox subbrowser-toolbox-horizontal">
				<xul:toolbar anonid="subbrowser-toolbar-horizontal"
					class="subbrowser-toolbar subbrowser-toolbar-horizontal chromeclass-extrachrome"
					align="center"
					flex="1"
				 	ondraggesture="
						this.parentNode.parentNode.parentNode.parentNode.toggleToolbar(false, true, 0);
				 		nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);
				 	"
					ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
					ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);">
					<xul:deck anonid="toolbar-deck"
						flex="1"
						onmouseover="this.parentNode.parentNode.parentNode.parentNode.parentNode.toggleToolbar(true);"
						onmouseout="this.parentNode.parentNode.parentNode.parentNode.parentNode.toggleToolbar(false);">
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center">
							<xul:box class="subbrowser-toolbar-item favicon-box">
								<xul:image class="subbrowser-toolbar-item favicon"
									anonid="favicon"
									validate="never"
									ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
									onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
							</xul:box>
							<xul:stack flex="1">
								<xul:progressmeter class="subbrowser-toolbar-item progress"
									anonid="progressmeter"
									collapsed="true"
									flex="1"/>
								<xul:label anonid="title"
									blank-label="&splitbrowser.subbrowser.blank;"
									loading-label="&splitbrowser.subbrowser.loading;"
									flex="1"
									crop="end"/>
							</xul:stack>
						</xul:hbox>
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center">
							<xul:toolbarbutton
								anonid="back-button"
								tooltiptext="&splitbrowser.subbrowser.goBack.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goBack();"
								class="subbrowser-toolbar-item button goBack"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="forward-button"
								tooltiptext="&splitbrowser.subbrowser.goForward.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goForward();"
								class="subbrowser-toolbar-item button goForward"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="reload-button"
								tooltiptext="&splitbrowser.subbrowser.reload.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.reload();"
								class="subbrowser-toolbar-item button reload"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="stop-button"
								tooltiptext="&splitbrowser.subbrowser.stop.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.stop();"
								class="subbrowser-toolbar-item button stop"
								disabled="true"/>
							<xul:hbox class="subbrowser-toolbar-item urlbar-box"
								align="center"
								flex="1">
								<xul:stack flex="1">
									<xul:progressmeter class="subbrowser-toolbar-item urlbar-progress"
										anonid="urlbar-progressmeter"
										collapsed="true"
										flex="1"/>
									<xul:textbox flex="1"
										anonid="urlbar"
										class="subbrowser-toolbar-item urlbar-textbox"
										ontextentered="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.load(this.value);"
										ontextreverted="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.load(this.value);"
										sizetopopup="pref"
										clickSelectsAll="true"
										type="autocomplete"
										autocompletesearch="history"
										autocompletepopup="PopupAutoComplete"
										completeselectedindex="true"
										tabscrolling="true"
										showcommentcolumn="true"
										enablehistory="true">
										<xul:box class="subbrowser-toolbar-item urlbar-favicon-box">
											<xul:image class="subbrowser-toolbar-item urlbar-favicon"
												anonid="urlbar-favicon"
												validate="never"
												onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
										</xul:box>
									</xul:textbox>
								 </xul:stack>
							</xul:hbox>
							<xul:toolbarbutton
								anonid="go-button"
								class="subbrowser-toolbar-item go"
								label="&splitbrowser.subbrowser.go.label;"
								tooltiptext="&splitbrowser.subbrowser.go.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.go();"/>
						</xul:hbox>
					</xul:deck>
					<xul:toolbarbutton
						anonid="close-button"
						class="tabs-closebutton toolbarbutton-1 chromeclass-toolbar-additional"
						tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
						oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.close();"/>
				</xul:toolbar>
				</xul:toolbox>
				<xul:hbox class="subbrowser-browser-box"
					flex="1">
					<xul:tabbrowser anonid="browser-tabbrowser"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onnewtab="
							var node = this;
							while (node.localName != 'tabbrowser') {
								node = node.parentNode;
							}
							node.parentNode.openNewTab();
						"
						onclick="return contentAreaClick(event, false);"
						ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.pageDNDObserver);"
						content="about:blank"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"
						disablehistory="true"/>
					<xul:browser anonid="browser-simple"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onclick="return contentAreaClick(event, false);"
						ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.pageDNDObserver);"
						content="about:blank"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"/>
				</xul:hbox>
			</xul:vbox>
		</xul:hbox>
	</content>

	<implementation>
		<property name="toolbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbar-horizontal');"/>

		<property name="hToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-horizontal');"/>
		<property name="vToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-vertical');"/>

		<property name="toolbarDeck" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar-deck');"/>

		<property name="browser" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'browser-'+this.browserType);"/>
		<property name="browserType" readonly="true"
			onget="return this.getAttribute('browsertype') == 'simple' ? 'simple' : 'tabbrowser' ;"/>

		<property name="backButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'back-button');"/>
		<property name="forwardButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'forward-button');"/>
		<property name="reloadButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'reload-button');"/>
		<property name="stopButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'stop-button');"/>
		<property name="urlbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar');"/>
		<property name="title" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'title');"/>
		<property name="favicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'favicon');"/>
		<property name="vFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-favicon');"/>
		<property name="urlbarFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-favicon');"/>
		<property name="progressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'progressmeter');"/>
		<property name="urlbarProgressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-progressmeter');"/>
		<property name="goButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'go-button');"/>
		<property name="contextmenu" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'contextmenu');"/>

		<property name="src"
			onset="this.setAttribute('src', val); this.load(val); return val;"
			onget="return this.getAttribute('src') || 'about:blank';"/>

		<property name="browserCollapsed" readonly="true"
			onget="return (this.boxObject.width == this.vToolbox.boxObject.width) || (this.boxObject.height == this.hToolbox.boxObject.height);"/>

		<method name="load">
			<parameter name="aURI"/>
			<body><![CDATA[
				if (!aURI) aURI = 'about:blank';
				this.browser.loadURI(aURI);
				this.setAttribute('src', aURI);
			]]></body>
		</method>

		<method name="goBack">
			<body><![CDATA[
				if (this.browser.canGoBack) {
					this.browser.goBack();
				}
			]]></body>
		</method>
		<method name="goForward">
			<body><![CDATA[
				if (this.browser.canGoForward) {
					this.browser.goForward();
				}
			]]></body>
		</method>
		<method name="reload">
			<body><![CDATA[
				this.browser.reload();
			]]></body>
		</method>
		<method name="stop">
			<body><![CDATA[
				this.browser.stop();
			]]></body>
		</method>

		<method name="go">
			<body><![CDATA[
				this.load(this.urlbar.value);
			]]></body>
		</method>

		<method name="close">
			<body><![CDATA[
				var event = document.createEvent('Events');
				event.initEvent('SubBrowserRemoveRequest', false, true);
				this.dispatchEvent(event);
			]]></body>
		</method>



		<method name="updateContextMenu">
			<parameter name="aEvent"/>
			<body><![CDATA[
				var popup = this.contextmenu;
				var collapsed = this.isCollapsed();
				popup.getElementsByAttribute('class', 'subbrowser-context-collapse')[0].hidden = collapsed;
				popup.getElementsByAttribute('class', 'subbrowser-context-expand')[0].hidden = !collapsed;

				var tabItem = popup.getElementsByAttribute('class', 'subbrowser-context-openNewTab')[0];
				tabItem.hidden = tabItem.previousSibling.hidden = (this.browser.localName != 'tabbrowser');
			]]></body>
		</method>

		<method name="isCollapsed">
			<body><![CDATA[
				var c = this.parentContainer;
				return c ? c.isCollapsed() : false ;
			]]></body>
		</method>

		<method name="toggleCollapsed">
			<body><![CDATA[
				var c = this.parentContainer;
				if (c) c.toggleCollapsed();
			]]></body>
		</method>



		<method name="updateToolbarForCurrentTab">
			<parameter name="aSwitchTab"/>
			<body><![CDATA[
				var b      = this.browser;
				var t      = null;
				var isBusy = this.mIsBusy;
				if (aSwitchTab) {
					t = b.mCurrentTab;
					isBusy = (t.getAttribute('busy') == 'true');
					this.mTotalProgress = t.mSubbrowserTabTotalProgress || 0 ;
				}

				if (this.mTotalProgress &&
					this.mTotalProgress < 1) {
					this.progressmeter.removeAttribute('collapsed');
					this.progressmeter.setAttribute('mode', 'normal');
					this.progressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));

					this.urlbarProgressmeter.removeAttribute('collapsed');
					this.urlbarProgressmeter.setAttribute('mode', 'normal');
					this.urlbarProgressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));
				}
				else {
					this.progressmeter.setAttribute('collapsed', true);
					this.urlbarProgressmeter.setAttribute('collapsed', true);
				}

				if (!isBusy) {
					this.stopButton.setAttribute('disabled', true);
					this.reloadButton.removeAttribute('disabled');

					if (t) {
						this.setIcon(t.getAttribute('image'));
					}
					else if (!this.mIconURL) {
						this.useDefaultIcon();
					}

					this.mIsBusy = false;
					this.removeAttribute('busy');

					try {
						if (b.canGoBack)
							this.backButton.removeAttribute('disabled');
						else
							this.backButton.setAttribute('disabled', true);

						if (b.canGoForward)
							this.forwardButton.removeAttribute('disabled');
						else
							this.forwardButton.setAttribute('disabled', true);
					}
					catch(e) {
						this.backButton.setAttribute('disabled', true);
						this.forwardButton.setAttribute('disabled', true);
					}

					this.title.setAttribute('value', b.contentDocument.title || this.title.getAttribute('blank-label'));
					this.updateIcon();
				}
				else {
					this.stopButton.removeAttribute('disabled');
					this.reloadButton.setAttribute('disabled', true);

					this.mIsBusy = true;
					this.setAttribute('busy', true);
					this.title.setAttribute('value', this.title.getAttribute('loading-label'));
					this.updateIcon();
				}
			]]></body>
		</method>



		<method name="toggleToolbar">
			<parameter name="aShow"/>
			<parameter name="aForce"/>
			<parameter name="aDelay"/>
			<body><![CDATA[
				if (this.browserCollapsed) aShow = false;

				if (this.mIsToolbarHover == aShow) return;

				this.mIsToolbarHover = aShow;

				if (aForce && aDelay === void(0)) {
					this.toolbarDeck.selectedIndex = aShow ? 1 : 0 ;
					return;
				}

				window.setTimeout(
					function(aShowFlag, aThis) {
						if (aShowFlag == aThis.mIsToolbarHover &&
							aThis.toolbarDeck)
							aThis.toolbarDeck.selectedIndex = aShowFlag ? 1 : 0 ;
					},
					(
						aDelay !== void(0) ? aDelay :
							this.mIsToolbarHover ?
								SplitBrowser.subBrowserToolbarShowDelay :
								SplitBrowser.subBrowserToolbarHideDelay
					),
					aShow,
					this
				);
			]]></body>
		</method>


		<method name="setIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				this.mIconURL = aURI;
				this.updateIcon();
			]]></body>
		</method>

		<method name="updateIcon">
			<body><![CDATA[
				if (!this.mIsBusy && this.mIconURL) {
					this.favicon.setAttribute('src', this.mIconURL);
					this.vFavicon.setAttribute('src', this.mIconURL);
					this.urlbarFavicon.setAttribute('src', this.mIconURL);
				}
				else {
					this.favicon.removeAttribute('src');
					this.vFavicon.removeAttribute('src');
					this.urlbarFavicon.removeAttribute('src');
				}
			]]></body>
		</method>

		<method name="useDefaultIcon">
			<body><![CDATA[
				if (this.browser.contentDocument instanceof ImageDocument) {
					if (nsPreferences.getBoolPref('browser.chrome.site_icons')) {
						try {
							var sz = nsPreferences.getIntPref('browser.chrome.image_icons.max_size');
							if (!sz)
								return;
							var req = this.browser.contentDocument.imageRequest;
							if (!req || !req.image || req.image.width > sz || req.image.height > sz)
								return;
							this.setIcon(this.browser.currentURI.spec);
						}
						catch (e) {
						}
					}
				}
				else if (this.shouldLoadFavIcon(this.browser.currentURI)) {
					var url = this.browser.currentURI.prePath + '/favicon.ico';
					if (!this.isIconKnownMissing(url))
						this.setIcon(url);
				}
			]]></body>
		</method>

		<method name="shouldLoadFavIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				return (
					aURI &&
					nsPreferences.getBoolPref('browser.chrome.site_icons') &&
					nsPreferences.getBoolPref('browser.chrome.favicons') &&
					('schemeIs' in aURI) &&
					(aURI.schemeIs('http') || aURI.schemeIs('https'))
				);
			]]></body>
		</method>

		<method name="addToMissedIconCache">
			<parameter name="aURI"/>
			<body><![CDATA[
				var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);
				if (!entry) return;

				if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)
					entry.setMetaDataElement('Icon', 'Missed');
				entry.markValid();
				entry.close();
			]]></body>
		</method>

		<method name="openCacheEntry">
			<parameter name="aKey"/>
			<parameter name="aAccess"/>
			<body><![CDATA[
				try {
					if (!this.mMissedIconCache) {
						var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);
						this.mMissedIconCache = cacheService.createSession('MissedIconCache', Components.interfaces.nsICache.STORE_ANYWHERE, true);
						if (!this.mMissedIconCache) return null;
					}
					return this.mMissedIconCache.openCacheEntry(aKey, aAccess, true);
				}
				catch (e) {
					return null;
				}
			]]></body>
		</method>

		<method name="isIconKnownMissing">
			<parameter name="aKey"/>
			<body><![CDATA[
				var e = this.openCacheEntry(aKey, Components.interfaces.nsICache.ACCESS_READ);
				if (e) {
					e.close();
					return true;
				}
				return false;
			]]></body>
		</method>

		<method name="onLinkAdded">
			<parameter name="aEvent"/>
			<body><![CDATA[
				if (!nsPreferences.getBoolPref('browser.chrome.site_icons')) return;
				if (!aEvent.originalTarget.rel.match((/(?:^|\s)icon(?:\s|$)/i))) return;

				var href = aEvent.originalTarget.href;
				if (!href) return;

				const nsIContentPolicy = Components.interfaces.nsIContentPolicy;
				try {
					var contentPolicy = Components.classes['@mozilla.org/layout/content-policy;1'].getService(nsIContentPolicy);
				}
				catch(e) {
					return;
				}

				const secMan = Components.classes['@mozilla.org/scriptsecuritymanager;1'].getService(Components.interfaces.nsIScriptSecurityManager);
				const ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);
				const targetDoc = aEvent.target.ownerDocument;
				var uri = ioService.newURI(href, targetDoc.characterSet, null);
				var origURI = ioService.newURI(targetDoc.documentURI, targetDoc.characterSet, null);

				const nsIScriptSecMan = Components.interfaces.nsIScriptSecurityManager;
				try {
					const aboutNeterr = 'about:neterror?';
					if (origURI.spec.substr(0, aboutNeterr.length) != aboutNeterr ||
						!uri.schemeIs('chrome'))
						secMan.checkLoadURI(origURI, uri, nsIScriptSecMan.DISALLOW_SCRIPT);
				}
				catch(e) {
					return;
				}

				if (contentPolicy.shouldLoad(
						nsIContentPolicy.TYPE_IMAGE,
						uri,
						origURI,
						aEvent.target,
						aEvent.target.type,
						null
					) != nsIContentPolicy.ACCEPT)
					return;

				if (targetDoc == this.browser.contentDocument)
					this.setIcon(href);
			]]></body>
		</method>



		<field name="pageDNDObserver"><![CDATA[
		({
			mOwner : this,

			onDragStart: function (aEvent, aXferData, aDragAction)
			{
				var value = this.mOwner.src;
				if (!value) return;

				var urlString = value + '\n' + this.mOwner.browser.contentDocument.title;
				var htmlString = '<a href="' + value + '">' + value + '</a>';

				aXferData.data = new TransferData();

				aXferData.data.addDataForFlavour('application/x-moz-splitbrowser',
					[
						'subbrowser',
						'id:'+this.mOwner.id,
						'uri:'+value,
						'width:'+this.mOwner.boxObject.width,
						'height:'+this.mOwner.boxObject.height
					].join('\n')
				);

				aXferData.data.addDataForFlavour('text/x-moz-url', urlString);
				aXferData.data.addDataForFlavour('text/unicode', value);
				aXferData.data.addDataForFlavour('text/html', htmlString);

				aDragAction.action =
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_COPY |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_MOVE |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_LINK;
			},

			onDragOver : function() {
			},

			onDrop: function (aEvent, aXferData, aDragSession)
			{
				aEvent.preventDefault();
				aEvent.preventBubble();

				var uri = SplitBrowser.getURIFromDragData(aXferData, aDragSession, aEvent);
				if (!uri) return;

				// fallback for Linux
				// in Linux, "dragdrop" event doesn't fire on the button.
				var forceCheck = aEvent.ctrlKey || aXferData.flavour.contentType == 'application/x-moz-splitbrowser';
				var check = this.mOwner.checkEventFiredOnEdge(aEvent, forceCheck);
				if (
					(forceCheck || SplitBrowser.isLinux) &&
					SplitBrowser.addButton.targetSubBrowser == this.mOwner &&
					(
						check.isTop ||
						check.isBottom ||
						check.isLeft ||
						check.isRight
					)
					) {
					SplitBrowser.fireSubBrowserAddRequestEventFromButton(uri);
					return;
				}

				this.mOwner.load(uri);
			},

			getSupportedFlavours: function ()
			{
				var flavourSet = new FlavourSet();
				flavourSet.appendFlavour('application/x-moz-splitbrowser');
				flavourSet.appendFlavour('text/x-moz-url');
				flavourSet.appendFlavour('text/unicode');
				flavourSet.appendFlavour('application/x-moz-file', 'nsIFile');
				return flavourSet;
			}
		})
		]]></field>


		<method name="openNewTab">
			<body><![CDATA[
				var b = this.browser;
				var t = b.addTab('about:blank');
				this.toggleToolbar(true, true, 0);
				window.setTimeout(function(aUrlbar) {
					b.selectedTab = t;
					window.setTimeout(function(aUrlbar) {
						aUrlbar.value = '';
						aUrlbar.focus();
					}, 0, aUrlbar);
				}, 0, this.urlbar);
			]]></body>
		</method>

		<method name="newAddTab">
			<body><![CDATA[
				var tab = this.__splitbrowser__addTab.apply(this, arguments);
				if (this.parentSubBrowser)
					this.parentSubBrowser.addProgressListener(tab);
				return tab;
			]]></body>
		</method>

		<method name="newRemoveTab">
			<body><![CDATA[
				if (this.parentSubBrowser)
					this.parentSubBrowser.removeProgressListener(arguments[0]);

				var result = this.__splitbrowser__removeTab.apply(this, arguments);

				if (this.mTabContainer.childNodes.length == 1) {
					this.setStripVisibilityTo(!nsPreferences.getBoolPref('splitbrowser.tabs.autoHide'));
				}

				return result;
			]]></body>
		</method>

		<method name="newUpdateCurrentBrowser">
			<body><![CDATA[
				var result = this.__splitbrowser__updateCurrentBrowser.apply(this, arguments);

				if (this.parentSubBrowser.focused) {
					gBrowser.mCurrentBrowser.removeAttribute('type');
					gBrowser.mCurrentBrowser.setAttribute('type', 'content');
				}
				else {
				}
					this.mCurrentBrowser.removeAttribute('type');
					this.mCurrentBrowser.setAttribute('type', 'content');

					gBrowser.mCurrentBrowser.removeAttribute('type');
					gBrowser.mCurrentBrowser.setAttribute('type', 'content-primary');
				}

				return result;
			]]></body>
		</method>

		<method name="addProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;

				var filter = Components.classes['@mozilla.org/appshell/component/browser-status-filter;1'].createInstance(Components.interfaces.nsIWebProgress);
				var listener = this.createProgressListener(aTab, browser);
				filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
				browser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);

				this.mTabListeners.push(listener);
				this.mTabFilters.push(filter);
			]]></body>
		</method>

		<method name="removeProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;
				var count = 0;

				if (aTab) {
					for (count = 0, maxc = this.mTabListeners.length; count < maxc; count++)
					{
						if (this.mTabListeners[count].mTab == aTab) break;
					}
				}

				browser.webProgress.removeProgressListener(this.mTabFilters[count]);
				this.mTabFilters[count].removeProgressListener(this.mTabListeners[count]);
				this.mTabFilters.splice(count, 1);
				this.mTabListeners.splice(count, 1);
			]]></body>
		</method>

		<method name="createProgressListener">
			<parameter name="aTab"/>
			<parameter name="aBrowser"/>
			<body><![CDATA[
			return {

			mOwner         : this,
            mTab           : aTab,
            mBrowser       : aBrowser,
            mTotalProgress : 0,

			onProgressChange: function (aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress)
			{
				this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
				if (this.mTab)
					this.mTab.mSubbrowserTabTotalProgress = this.mTotalProgress;

				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.mTotalProgress = this.mTotalProgress;
				this.mOwner.updateToolbarForCurrentTab();
			},

			onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
				if (
					aStateFlags & nsIWebProgressListener.STATE_START &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = true;
					this.mOwner.updateToolbarForCurrentTab();
				}
				else if (
					aStateFlags & nsIWebProgressListener.STATE_STOP &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = false;
					this.mOwner.updateToolbarForCurrentTab();
				}
			},

			onLocationChange : function(aWebProgress, aRequest, aLocation)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.urlbar.value = aLocation.spec;
				this.mOwner.setAttribute('src', aLocation.spec);

				if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
					aWebProgress.isLoadingDocument)
					this.mOwner.setIcon(null);
			},

			onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
			{
			},

			onSecurityChange : function(aWebProgress, aRequest, aState)
			{
			},

			QueryInterface : function(aIID)
			{
				if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
					aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
					aIID.equals(Components.interfaces.nsISupports))
					return this;
				throw Components.results.NS_NOINTERFACE;
			}

			};
			]]></body>
		</method>

		<field name="mTabListeners">[]</field>
		<field name="mTabFilters">[]</field>

		<constructor><![CDATA[
			var b = this.browser;
			if (b.nextSibling && b.nextSibling.localName == 'browser')
				b.parentNode.removeChild(b.nextSibling);
			if (b.previousSibling && b.previousSibling.localName == 'tabbrowser')
				b.parentNode.removeChild(b.previousSibling);

			b.parentSubBrowser = this;

			if (b.localName == 'tabbrowser') {
				b.__splitbrowser__addTab = b.addTab;
				b.addTab = this.newAddTab;
				b.__splitbrowser__removeTab = b.removeTab;
				b.removeTab = this.newRemoveTab;
				b.__splitbrowser__updateCurrentBrowser = b.updateCurrentBrowser;
				b.updateCurrentBrowser = this.newUpdateCurrentBrowser;

				b.mTabContainer.addEventListener('select', this.onTabSelectHandler, false);

				window.setTimeout(function(aThis) {
					aThis.mDelayedTabbrowserStartup();
				}, 0, this);

				var newEvent = document.createEvent('Events');
				newEvent.tabbrowser = b;
				newEvent.initEvent('SubBrowserTabbrowserInserted', false, true);
				this.dispatchEvent(newEvent);
			}
			else {
				this.addProgressListener(null);
				if (this.getAttribute('src'))
					this.load(this.getAttribute('src'));
			}
		]]></constructor>

		<method name="mDelayedTabbrowserStartup">
			<parameter name="aThis"/>
			<body><![CDATA[
			var b = this.browser;
			this.addProgressListener(b.mCurrentTab);

			var autoHide = nsPreferences.getBoolPref('splitbrowser.tabs.autoHide');
			b.setStripVisibilityTo(!autoHide);

			b = b.mCurrentBrowser;
			b.setAttribute('type', 'content');

			gBrowser.mCurrentBrowser.removeAttribute('type');
			gBrowser.mCurrentBrowser.setAttribute('type', 'content-primary');

			b.webNavigation.sessionHistory = Components.classes['@mozilla.org/browser/shistory;1'].createInstance(Components.interfaces.nsISHistory);

			var os = Components.classes['@mozilla.org/observer-service;1'].getService(Components.interfaces.nsIObserverService);
			os.addObserver(b, 'browser:purge-session-history', false);
			b.removeAttribute('disablehistory');
			b.docShell.QueryInterface(Components.interfaces.nsIDocShellHistory).useGlobalHistory = true;

			if (this.getAttribute('src'))
				this.load(this.getAttribute('src'));
			]]></body>
		</method>


		<destructor><![CDATA[
			var b = this.browser;
			if (b.localName == 'tabbrowser') {
				for (var i = 0, maxi = b.mTabContainer.childNodes.length; i < maxi; i++)
				{
					this.removeProgressListener(b.mTabContainer.childNodes[i]);
				}
				b.mTabContainer.removeEventListener('select', this.onTabSelectHandler, false);
			}
			else {
				this.removeProgressListener();
			}

			b.parentSubBrowser = null;
		]]></destructor>


		<field name="onTabSelectHandler"><![CDATA[
			({
				mOwner      : this,
				handleEvent : function(aEvent)
				{
					switch (aEvent.type)
					{
						case 'select':
							this.mOwner.updateToolbarForCurrentTab(true);
							break;
					}
				}
			})
		]]></field>


		<field name="focused">false</field>

<!--
		<method name="onFocus">
			<body><![CDATA[
				window.setTimeout(function(aThis) {
					aThis.focused = true;
					gBrowser.mCurrentBrowser.removeAttribute('type');
					gBrowser.mCurrentBrowser.setAttribute('type', 'content');
					aThis.browser.mCurrentBrowser.removeAttribute('type');
					aThis.browser.mCurrentBrowser.setAttribute('type', 'content-primary');
				}, 0, this);
			]]></body>
		</method>

		<method name="onBlur">
			<body><![CDATA[
				this.focused = false;
				this.browser.mCurrentBrowser.removeAttribute('type');
				this.browser.mCurrentBrowser.setAttribute('type', 'content');
				gBrowser.mCurrentBrowser.removeAttribute('type');
				gBrowser.mCurrentBrowser.setAttribute('type', 'content-primary');
			]]></body>
		</method>
-->

	</implementation>

	<handlers>
		<handler event="DOMLinkAdded" phase="capturing"
			action="this.onLinkAdded(event);"/>

<!--
		<handler event="focus" phase="capturing"
			action="this.onFocus();"/>

		<handler event="blur" phase="capturing"
			action="this.onBlur();"/>
-->
	</handlers>
</binding>


</bindings>
