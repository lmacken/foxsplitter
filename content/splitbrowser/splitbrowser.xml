<?xml version="1.0"?>

<!DOCTYPE overlay [
	<!ENTITY % mainDTD SYSTEM "chrome://splitbrowser/locale/" >
	%mainDTD;
]>

<bindings id="splitbrowserBindings"
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
	xmlns:xbl="http://www.mozilla.org/xbl">

<binding id="contents-in-container" extends="xul:vbox">
	<implementation>
		<property name="parentContainer" readonly="true">
			<getter><![CDATA[
				var container = this.parentNode;
				while (container.localName != 'subbrowser-container' &&
						container.parentNode)
				{
					container = container.parentNode;
				}

				return (container.localName == 'subbrowser-container') ? container : null ;
			]]></getter>
		</property>

		<property name="flexibleParent" readonly="true">
			<getter><![CDATA[
				var c = this;
				while (
					c &&
					c != document.documentElement &&
					!c.nextSibling &&
					!c.previousSibling
					)
					c = c.parentNode;

				return c == document.documentElement ? null : c ;
			]]></getter>
		</property>

		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>

		<field name="lastwidth">-1</field>
		<field name="lastheight">-1</field>
	</implementation>
</binding>



<binding id="container" extends="#contents-in-container">
	<!--content orient="vertical">
		<xul:vbox anonid="vertical-container" flex="1"
			class="vertical-container">
			<xul:hbox anonid="horizontal-container" flex="1"
				class="horizontal-container"/>
		</xul:vbox>
	</content-->

	<implementation>
<!--
		<field name="hContainer">null</field>
		<field name="vContainer">null</field>
-->
		<constructor><![CDATA[
			if (
				this.vContainer ||
				this.localName != 'subbrowser-container' ||
				(
					this.hasChildNodes() &&
					this.firstChild.getAttribute('class') == 'vertical-container'
				)
				)
				return;

			this.vContainer = document.createElement('vbox');
			this.vContainer.setAttribute('class', 'vertical-container');
			this.vContainer.setAttribute('flex', 1);
			this.appendChild(this.vContainer);

			this.hContainer = document.createElement('hbox');
			this.hContainer.setAttribute('class', 'horizontal-container');
			this.hContainer.setAttribute('flex', 1);
			this.vContainer.appendChild(this.hContainer);

		]]></constructor>

		<property name="vContentCollapsed" readonly="true"
			onget="return this.vContainer.vContentCollapsed || (this.hContainer ? this.hContainer.vContentCollapsed : false );"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.vContainer.hContentCollapsed || (this.hContainer ? this.hContainer.hContentCollapsed : false );"/>

		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContainer.vContentCompletelyCollapsed &amp;&amp; (this.hContainer ? this.hContainer.vContentCompletelyCollapsed : false );"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.vContainer.hContentCompletelyCollapsed &amp;&amp; (this.hContainer ? this.hContainer.hContentCompletelyCollapsed : false );"/>
	</implementation>

	<handlers>
		<handler event="mousedown"><![CDATA[
			var newEvent = document.createEvent('Events');
			newEvent.force = true;
			newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
			this.dispatchEvent(newEvent);
		]]></handler>
	</handlers>
</binding>

<binding id="horizontal-container" extends="xul:hbox">
	<implementation>
		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="vContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].vContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>
		<property name="hContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].hContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>

		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>
		<property name="vContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].vContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
		<property name="hContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].hContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
	</implementation>
</binding>

<binding id="vertical-container" extends="xul:vbox">
	<implementation>
		<property name="contentCollapsed" readonly="true"
			onget="return this.vContentCollapsed || this.hContentCollapsed;"/>
		<property name="vContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].vContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>
		<property name="hContentCollapsed" readonly="true">
			<getter><![CDATA[
				var collapsed = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (nodes[i].hContentCollapsed)
						return true;

				return false;
			]]></getter>
		</property>

		<property name="contentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCompletelyCollapsed || this.hContentCompletelyCollapsed;"/>
		<property name="vContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].vContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
		<property name="hContentCompletelyCollapsed" readonly="true">
			<getter><![CDATA[
				var expanded = 0;

				var nodes = this.childNodes;
				for (var i = 0, maxi = nodes.length; i < maxi; i = i+2)
					if (!nodes[i].hContentCompletelyCollapsed)
						return false;

				return true;
			]]></getter>
		</property>
	</implementation>
</binding>

<binding id="toplevel-container" extends="#container">
	<content orient="vertical">
		<xul:vbox anonid="primary-browser-inner-container" flex="1">
			<xul:vbox anonid="vertical-container" flex="1"
				class="vertical-container">
				<xul:hbox anonid="horizontal-container" flex="1"
					class="horizontal-container">
					<xul:vbox anonid="primary-browser-wrapper" flex="1"
						class="primary-browser-wrapper">
						<children/>
					</xul:vbox>
				</xul:hbox>
			</xul:vbox>
		</xul:vbox>
	</content>

	<implementation>
		<property name="hContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'horizontal-container'); } catch(e) { return null; }"/>
		<property name="vContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-container'); } catch(e) { return null; }"/>
		<property name="contentWrapper" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'primary-browser-wrapper'); } catch(e) { return null; }"/>

		<property name="innerContainer" readonly="true"
			onget="try { return document.getAnonymousElementByAttribute(this, 'anonid', 'primary-browser-inner-container'); } catch(e) { return null; }"/>
	</implementation>
</binding>



<binding id="subbrowser-base" extends="#contents-in-container">
	<implementation>
		<property name="rightOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxY > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="bottomOffset" readonly="true">
			<getter><![CDATA[
				var win = (this.browser || gBrowser).contentWindow;
				return (win.scrollMaxX > 0) ? SplitBrowser.scrollbarSize : 0 ;
			]]></getter>
		</property>

		<property name="contentAreaSizeObject" readonly="true">
			<getter><![CDATA[
				if (!this.browser) return null;
				var box, retVal;
				if (this.localName == 'subbrowser') {
					if (this.browser.localName == 'tabbrowser')
						box = this.browser.mCurrentBrowser;
					else
						box = this.browser;
				}
				else
					box = gBrowser.mCurrentBrowser;

				retVal =  { box : box };

				box = box.boxObject;
				retVal.x       = box.x;
				retVal.y       = box.y;
				retVal.screenX = box.screenX;
				retVal.screenY = box.screenY;
				retVal.width   = box.width - this.rightOffset;
				retVal.height  = box.height - this.bottomOffset;

				retVal.middleX = parseInt(box.x + (box.width / 2));
				retVal.middleY = parseInt(box.y + (box.height / 2));
				retVal.middleScreenX = parseInt(box.screenX + (box.width / 2));
				retVal.middleScreenY = parseInt(box.screenY + (box.height / 2));

				retVal.areaWidth   = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.width * 0.6));
				retVal.areaX       = retVal.middleX - parseInt(retVal.areaWidth / 2);
				retVal.areaScreenX = retVal.middleScreenX - parseInt(retVal.areaWidth / 2);
				retVal.areaHeight  = parseInt(Math.min(SplitBrowser.addButtonAreaSize, box.height * 0.6));
				retVal.areaY       = retVal.middleY - parseInt(retVal.areaHeight / 2);
				retVal.areaScreenY = retVal.middleScreenY - parseInt(retVal.areaHeight / 2);

				return retVal;
			]]></getter>
		</property>

		<property name="src" readonly="true"
			onget="return gBrowser.currentURI.spec;"/>

		<method name="toggleCollapsed">
			<body><![CDATA[
				if (this.contentCollapsed)
					this.expand();
				else
					this.collapse();
			]]></body>
		</method>

		<method name="collapse">
			<body><![CDATA[
				var c = this.flexibleParent;
				if (!c) return;

				var splitter = c.nextSibling || c.previousSibling;
				var prop     = (splitter.getAttribute('orient') != 'vertical') ? 'width' : 'height' ;
				var cProp    = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;
				var cCProp   = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCompletelyCollapsed' : 'vContentCompletelyCollapsed' ;

				if (this[cProp]) return;

				var sideBox = this.findSideBox(
						c,
						(c.getAttribute('splitter') == 'before' ? -1 : 1 ),
						(splitter.getAttribute('orient') != 'vertical' ? 'horizontal' : 'vertical' )
					);
				if (!sideBox) return;

/*
var col = (['red', 'blue', 'green'])[parseInt(Math.random() * 3)];
c.setAttribute('style', 'border: 2px dotted '+col+' !important;');
sideBox.setAttribute('style', 'border: 2px solid '+col+' !important;');
window.setTimeout(function() {
c.removeAttribute('style');
sideBox.removeAttribute('style');
}, 2000);
*/

				var origSize = c.boxObject[prop];
				var sideSize = sideBox.boxObject[prop];

				c['last'+prop] = origSize;
				c.setAttribute(prop, 0);
				sideBox.removeAttribute('max'+prop);
				sideBox.setAttribute(prop, sideSize + origSize);
				c.setAttribute('max'+prop, 0);
				this.blur();

				window.setTimeout(function(aThis) {
					aThis.toggleNavigation(false);
					aThis.mUpdateToolbarMode();

					var node = c.parentNode;
					var appcontent = document.getElementById('appcontent');
					while (node && node != appcontent)
					{
						if (cCProp in node && node[cCProp])
							node.setAttribute('max'+prop, 0);
						node = node.parentNode;
					}
				}, 0, this);
			]]></body>
		</method>

		<method name="expand">
			<parameter name="aForce"/>
			<body><![CDATA[
				var c = this.flexibleParent;
				if (!c) return;

				var splitter = c.nextSibling || c.previousSibling;
				var prop     = (splitter.getAttribute('orient') == 'horizontal') ? 'width' : 'height' ;
				var cProp    = (splitter.getAttribute('orient') != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;

				if (!this[cProp]) return;

				var sideBox = this.findSideBox(
						c,
						(c.getAttribute('splitter') == 'before' ? -1 : 1 ),
						(splitter.getAttribute('orient') != 'vertical' ? 'horizontal' : 'vertical' )
					);
				if (!sideBox) return;

/*
var col = (['red', 'blue', 'green'])[parseInt(Math.random() * 3)];
c.setAttribute('style', 'border: 2px dotted '+col+' !important;');
sideBox.setAttribute('style', 'border: 2px solid '+col+' !important;');
window.setTimeout(function() {
c.removeAttribute('style');
sideBox.removeAttribute('style');
}, 2000);
*/

				var origSize = c.boxObject[prop];
				var sideSize = sideBox.boxObject[prop];

				var node = c;
				var appcontent = document.getElementById('appcontent');
				var sideBoxPos = 'before';
				do {
					node.removeAttribute('max'+prop);
					if (node.nextSibling && node.nextSibling.nextSibling == sideBox)
						sideBoxPos = 'after';
					node = node.parentNode;
				}
				while (node && node != appcontent)

				if (c['last'+prop] === void(0) || c['last'+prop] <= 0)
					c['last'+prop] = parseInt(sideSize * 2 / 5);
				c.setAttribute(prop, c['last'+prop]);
				sideBox.setAttribute(prop, sideSize - (c['last'+prop] - origSize));
				c['last'+prop] = -1;

				this.clearMaxSizeProp(
					((sideBoxPos == 'after') ? sideBox.previousSibling.previousSibling : sideBox.nextSibling.nextSibling ),
					prop
				);


				window.setTimeout(function(aThis) {
					aThis.toggleNavigation((aThis.getAttribute('toolbar-navigation') == 'true'));
					aThis.mUpdateToolbarMode();
				}, 0, this);
			]]></body>
		</method>
		<method name="clearMaxSizeProp">
			<parameter name="aNode"/>
			<parameter name="aProp"/>
			<body><![CDATA[
				aNode.removeAttribute('max'+aProp);
				if (aNode['last'+aProp]) aNode['last'+aProp] = -1;
				if (aNode == this) return;
				for (var i = 0, maxi = aNode.childNodes.length; i < maxi; i = i+2)
				{
					this.clearMaxSizeProp(aNode.childNodes[i], aProp);
				}
			]]></body>
		</method>


		<method name="findSideBox">
			<parameter name="aBox"/>
			<parameter name="aDir"/>
			<parameter name="aOrient"/>
			<parameter name="aFindAny"/>
			<body><![CDATA[
				var cProp  = (aOrient != 'vertical') ? 'hContentCollapsed' : 'vContentCollapsed' ;

				var target = aBox;
				if (aDir < 0) {
					while (target && target.previousSibling)
					{
						target = target.previousSibling.previousSibling;
						if (aFindAny || !target[cProp]) return target;
					}

					target = aBox;
					while (target && target.nextSibling)
					{
						target = target.nextSibling.nextSibling;
						if (aFindAny || !target[cProp]) return target;
					}
				}
				else {
					while (target && target.nextSibling)
					{
						target = target.nextSibling.nextSibling;
						if (aFindAny || !target[cProp]) return target;
					}

					target = aBox;
					while (target && target.previousSibling)
					{
						target = target.previousSibling.previousSibling;
						if (aFindAny || !target[cProp]) return target;
					}
				}

				var appcontent = document.getElementById('appcontent');

				target = aBox;
				var orientBox;
				do {
					target = target.parentNode;

					orientBox = (target.localName == 'subbrowser-container') ? (target.previousSibling || target.nextSibling || target.parentNode) : target ;
					if (orientBox.localName == 'splitter') {
						if (orientBox.getAttribute('orient') != aOrient)
							continue;
						else
							break;
					}
					else {
						if (window.getComputedStyle(orientBox, '').getPropertyValue('-moz-box-orient') != aOrient)
							continue;
						else
							break;
					}
				}
				while (target != appcontent);

				if (target == appcontent)
					return null;
				else
					return this.findSideBox(target, aDir, aOrient);
			]]></body>
		</method>

		<method name="checkEventFiredOnEdge">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<body><![CDATA[
				if (this.contentCollapsed) {
					return {
						isTop    : false,
						isBottom : false,
						isLeft   : false,
						isRight  : false
					};
				}

				var offset   = SplitBrowser.addButtonSize;
				var box      = this.contentAreaSizeObject;
				if (!box) return null;

				if (aForceFire || aEvent.ctrlKey) {
					var pos = SplitBrowser.getDropPositionOnContentArea(aEvent, box.box);
					return {
						isTop    : pos == SplitBrowser.POSITION_TOP,
						isBottom : pos == SplitBrowser.POSITION_BOTTOM,
						isLeft   : pos == SplitBrowser.POSITION_LEFT,
						isRight  : pos == SplitBrowser.POSITION_RIGHT
					};
				}

				var isTop    = (aEvent.screenY >= box.screenY &&
								aEvent.screenY < box.screenY+offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isBottom = (aEvent.screenY <= box.screenY+box.height &&
								aEvent.screenY > box.screenY+box.height-offset &&
								aEvent.screenX >= box.areaScreenX &&
								aEvent.screenX < box.areaScreenX+box.areaWidth);
				var isLeft   = (aEvent.screenX >= box.screenX &&
								aEvent.screenX < box.screenX+offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);
				var isRight  = (aEvent.screenX <= box.screenX+box.width &&
								aEvent.screenX > box.screenX+box.width-offset &&
								aEvent.screenY >= box.areaScreenY &&
								aEvent.screenY < box.areaScreenY+box.areaHeight);

				return {
					isTop    : isTop,
					isBottom : isBottom,
					isLeft   : isLeft,
					isRight  : isRight
				};
			]]></body>
		</method>

		<method name="handleMouseOverEvent">
			<parameter name="aEvent"/>
			<parameter name="aForceFire"/>
			<body><![CDATA[
				var check = this.checkEventFiredOnEdge(aEvent, aForceFire);
				if (!check) return;

				if (
					check.isTop ||
					check.isBottom ||
					check.isLeft ||
					check.isRight
					) {
					if (
						(check.isTop && !this.mIsMouseOverTop) ||
						(check.isBottom && !this.mIsMouseOverBottom) ||
						(check.isLeft && !this.mIsMouseOverLeft) ||
						(check.isRight && !this.mIsMouseOverRight)
						) {
						this.mIsMouseOverTop    = check.isTop;
						this.mIsMouseOverBottom = check.isBottom;
						this.mIsMouseOverLeft   = check.isLeft;
						this.mIsMouseOverRight  = check.isRight;

						var newEvent = document.createEvent('Events');
						newEvent.initEvent('SubBrowserEnterContentAreaEdge', false, true);
						newEvent.isTop    = check.isTop;
						newEvent.isBottom = check.isBottom;
						newEvent.isLeft   = check.isLeft;
						newEvent.isRight  = check.isRight;
						newEvent.targetSubBrowser = this;
						newEvent.firedBy = aEvent.type;
						this.dispatchEvent(newEvent);
					}
				}
				else {
					this.mIsMouseOverTop    = false;
					this.mIsMouseOverBottom = false;
					this.mIsMouseOverLeft   = false;
					this.mIsMouseOverRight  = false;

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserExitContentAreaEdge', false, true);
					this.dispatchEvent(newEvent);
				}
			]]></body>
		</method>

		<method name="handleDragOverEvent">
			<parameter name="aEvent"/>
			<body><![CDATA[
				const DragService = Components.classes['@mozilla.org/widget/dragservice;1'].getService(Components.interfaces.nsIDragService);
				var session = DragService.getCurrentSession();
				if (!session) return;

				var isSubBrowser = session.isDataFlavorSupported('application/x-moz-splitbrowser');
				if (isSubBrowser ||
					session.isDataFlavorSupported('text/x-moz-url') ||
					session.isDataFlavorSupported('text/unicode') ||
					session.isDataFlavorSupported('application/x-moz-file')) {
					this.handleMouseOverEvent(aEvent, isSubBrowser);
					var check = this.checkEventFiredOnEdge(aEvent, isSubBrowser);
					if (!check) return;

					if (
						SplitBrowser.isLinux &&
						SplitBrowser.addButton.targetBrowser == this &&
						(
							check.isTop ||
							check.isBottom ||
							check.isLeft ||
							check.isRight
						)
						) {
						session.canDrop = true;
					}
				}
			]]></body>
		</method>


		<property name="focused">
			<setter><![CDATA[
				if (this.contentCollapsed)
					val = false;

				var b = this.browser;
				if (b && b.localName == 'tabbrowser')
					b = b.mCurrentBrowser;

				if (val || !SplitBrowser.browsers.length) {
					this.setAttribute('subbrowser-focused', true);
					if (b) {
						b.removeAttribute('type');
						b.setAttribute('type', 'content-primary');
					}
				}
				else if (SplitBrowser.browsers.length) {
					this.removeAttribute('subbrowser-focused');
					if (b) {
						b.removeAttribute('type');
						b.setAttribute('type', 'content');
					}
				}
				return val;
			]]></setter>
			<getter><![CDATA[
				return this.getAttribute('subbrowser-focused') == 'true';
			]]></getter>
		</property>

		<method name="focus">
			<body><![CDATA[
				if (SplitBrowser.activeSubBrowser != this)
					SplitBrowser.activeSubBrowser = this;
				this.focused = true;
			]]></body>
		</method>
		<method name="blur">
			<body><![CDATA[
				if (SplitBrowser.activeSubBrowser == this)
					SplitBrowser.activeSubBrowser = null;
				this.focused = false;
			]]></body>
		</method>

		<method name="autoFocus">
			<body><![CDATA[
				var delay = SplitBrowser.subBrowserAutoFocusDelay;
				if (
					this.focused ||
					this.mAutoFocusTimer ||
					delay < 0
					)
					return;

				this.mAutoFocusTimer = window.setTimeout(
					function(aThis) {
						aThis.focus();
						aThis.cancelAutoFocus();
					},
					delay,
					this
				);
			]]></body>
		</method>
		<method name="cancelAutoFocus">
			<body><![CDATA[
				if (this.mAutoFocusTimer) {
					window.clearInterval(this.mAutoFocusTimer);
					this.mAutoFocusTimer = null;
				}
			]]></body>
		</method>
		<field name="mAutoFocusTimer">null</field>

	</implementation>

	<handlers>
		<handler event="mousemove"
			action="if (nsPreferences.getBoolPref('splitbrowser.show.addbuttons.hover')) this.handleMouseOverEvent(event); return true;"/>
		<handler event="dragover" phase="capturing"
			action="if (nsPreferences.getBoolPref('splitbrowser.show.addbuttons.dragdrop')) this.handleDragOverEvent(event); return true;"/>

		<handler event="focus" phase="capturing"
			action="this.focus();"/>

		<handler event="mouseover"
			action="window.setTimeout(function(aThis) { aThis.autoFocus(); }, 0, this);"/>
		<handler event="mouseout"
			action="this.cancelAutoFocus();"/>
	</handlers>
</binding>

<binding id="subbrowser-primary" extends="#subbrowser-base">
	<implementation>
		<property name="vContentCollapsed" readonly="true"
			onget="return this.boxObject.width == 0;"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.boxObject.height == 0;"/>
		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCollapsed"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.hContentCollapsed"/>
		<property name="browser" readonly="true"
			onget="return gBrowser;"/>
	</implementation>
</binding>

<binding id="subbrowser" extends="#subbrowser-base">
	<content orient="vertical"
		context="_child">
		<xul:menupopup anonid="contextmenu"
			onpopupshowing="
				this.parentNode.resetNavigation();
				this.parentNode.updateContextMenu(event);
			"
			oncommand="this.parentNode.resetNavigation();"
			ondraggesture="event.stopPropagation();">
			<xul:menuitem class="subbrowser-context-close"
				label="&splitbrowser.subbrowser.menu.close;"
				oncommand="this.parentNode.parentNode.close();"/>
			<xul:menuitem class="subbrowser-context-collapse"
				label="&splitbrowser.subbrowser.menu.collapse;"
				oncommand="this.parentNode.parentNode.collapse();"/>
			<xul:menuitem class="subbrowser-context-expand"
				label="&splitbrowser.subbrowser.menu.expand;"
				oncommand="this.parentNode.parentNode.expand();"/>
			<xul:menuseparator/>
			<xul:menuitem class="subbrowser-context-openNewTab"
				label="&splitbrowser.subbrowser.menu.openNewTab;"
				oncommand="this.parentNode.parentNode.openNewTab();"/>
		</xul:menupopup>
		<xul:hbox flex="1" class="subbrowser-content">
			<xul:toolbox anonid="subbrowser-toolbox-vertical"
				orient="vertical"
				class="subbrowser-toolbox subbrowser-toolbox-vertical">
			<xul:toolbar anonid="subbrowser-toolbar-vertical"
				orient="vertical"
				flex="1"
				class="subbrowser-toolbar subbrowser-toolbar-vertical"
				align="center"
			 	ondraggesture="
			 		nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.pageDNDObserver);
			 	"
				ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.pageDNDObserver);"
				ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode.pageDNDObserver);"
				onclick="if (event.button == 1) this.parentNode.parentNode.parentNode.toggleCollapsed();"
				ondblclick="this.parentNode.parentNode.parentNode.toggleCollapsed();">
				<xul:toolbarbutton
					anonid="close-button-vertical"
					class="tabs-closebutton toolbarbutton-1"
					tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
					oncommand="this.parentNode.parentNode.parentNode.parentNode.close();"
					ondblclick="event.stopPropagation();"/>
				<xul:toolbarbutton
					anonid="collapse-button-vertical"
					tooltiptext="&splitbrowser.subbrowser.collapse.tooltip;"
					oncommand="this.parentNode.parentNode.parentNode.parentNode.collapse();"
					ondblclick="event.stopPropagation();"
					class="subbrowser-toolbar-item button collapse"/>
				<xul:toolbarbutton
					anonid="expand-button-vertical"
					tooltiptext="&splitbrowser.subbrowser.expand.tooltip;"
					oncommand="this.parentNode.parentNode.parentNode.parentNode.expand();"
					ondblclick="event.stopPropagation();"
					class="subbrowser-toolbar-item button expand"/>
				<xul:box class="subbrowser-toolbar-item favicon-box">
					<xul:image class="subbrowser-toolbar-item favicon"
						anonid="vertical-favicon"
						validate="never"
						onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
				</xul:box>
				<xul:description anonid="vertical-title"
					class="subbrowser-title subbrowser-vertical-title"
					flex="1"/>
			</xul:toolbar>
			</xul:toolbox>
			<xul:vbox flex="1">
				<xul:toolbox anonid="subbrowser-toolbox-horizontal"
					orient="horizontal"
					class="subbrowser-toolbox subbrowser-toolbox-horizontal">
				<xul:toolbar anonid="subbrowser-toolbar-horizontal"
					class="subbrowser-toolbar subbrowser-toolbar-horizontal"
					align="center"
					flex="1"
				 	ondraggesture="
						this.parentNode.parentNode.parentNode.parentNode.resetNavigation();
				 		nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);
				 	"
					ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
					ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
				 	onclick="
				 		if (event.button == 0 &amp;&amp;
				 			this.firstChild.getAttribute('selectedIndex') == '0')
							this.parentNode.parentNode.parentNode.parentNode.resetNavigation();
				 		if (event.button == 1)
				 			this.parentNode.parentNode.parentNode.parentNode.toggleCollapsed();
				 	"
					ondblclick="this.parentNode.parentNode.parentNode.parentNode.toggleCollapsed();">
					<xul:stack anonid="toolbar-deck"
						flex="1"
						onmouseover="this.parentNode.parentNode.parentNode.parentNode.parentNode.toggleNavigationOnHover(true);"
						onmouseout="this.parentNode.parentNode.parentNode.parentNode.parentNode.toggleNavigationOnHover(false);"
						selectedIndex="0">
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center"
							anonid="toolbar-deck-titlebar">
							<xul:box class="subbrowser-toolbar-item favicon-box">
								<xul:image class="subbrowser-toolbar-item favicon"
									anonid="favicon"
									validate="never"
									ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
									onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
							</xul:box>
							<xul:stack flex="1">
								<xul:progressmeter class="subbrowser-toolbar-item progress"
									anonid="progressmeter"
									collapsed="true"
									flex="1"/>
								<xul:label anonid="title"
									class="subbrowser-title"
									blank-label="&splitbrowser.subbrowser.blank;"
									loading-label="&splitbrowser.subbrowser.loading;"
									flex="1"
									crop="end"/>
							</xul:stack>
						</xul:hbox>
						<xul:hbox class="subbrowser-toolbar-content" flex="1" align="center"
							anonid="toolbar-deck-navbar">
							<xul:toolbarbutton
								anonid="back-button"
								tooltiptext="&splitbrowser.subbrowser.goBack.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goBack();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button goBack"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="forward-button"
								tooltiptext="&splitbrowser.subbrowser.goForward.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goForward();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button goForward"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="reload-button"
								tooltiptext="&splitbrowser.subbrowser.reload.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.reload();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button reload"
								disabled="true"/>
							<xul:toolbarbutton
								anonid="stop-button"
								tooltiptext="&splitbrowser.subbrowser.stop.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.stop();"
								ondblclick="event.stopPropagation();"
								class="subbrowser-toolbar-item button stop"
								disabled="true"/>
							<xul:hbox class="subbrowser-toolbar-item urlbar-box"
								align="center"
								flex="1">
								<xul:stack flex="1">
									<xul:progressmeter class="subbrowser-toolbar-item urlbar-progress"
										anonid="urlbar-progressmeter"
										collapsed="true"
										flex="1"/>
									<xul:textbox flex="1"
										anonid="urlbar"
										class="subbrowser-toolbar-item urlbar-textbox"
										ontextentered="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.load(this.value);"
										ontextreverted="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.load(this.value);"
										onclick="event.stopPropagation();"
										ondblclick="event.stopPropagation();"
										sizetopopup="pref"
										clickSelectsAll="true"
										type="autocomplete"
										autocompletesearch="history"
										autocompletepopup="PopupAutoComplete"
										completeselectedindex="true"
										tabscrolling="true"
										showcommentcolumn="true"
										enablehistory="true">
										<xul:box class="subbrowser-toolbar-item urlbar-favicon-box">
											<xul:image class="subbrowser-toolbar-item urlbar-favicon"
												anonid="urlbar-favicon"
												validate="never"
												onerror="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('src')); this.removeAttribute('src');"/>
										</xul:box>
									</xul:textbox>
								 </xul:stack>
							</xul:hbox>
							<xul:toolbarbutton
								anonid="go-button"
								class="subbrowser-toolbar-item go"
								label="&splitbrowser.subbrowser.go.label;"
								tooltiptext="&splitbrowser.subbrowser.go.tooltip;"
								oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.go();"
								ondblclick="event.stopPropagation();"/>
						</xul:hbox>
					</xul:stack>
					<xul:toolbarbutton
						anonid="collapse-button"
						tooltiptext="&splitbrowser.subbrowser.collapse.tooltip;"
						oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.collapse();"
						ondblclick="event.stopPropagation();"
						class="subbrowser-toolbar-item button collapse"/>
					<xul:toolbarbutton
						anonid="expand-button"
						tooltiptext="&splitbrowser.subbrowser.expand.tooltip;"
						oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.expand();"
						ondblclick="event.stopPropagation();"
						class="subbrowser-toolbar-item button expand"/>
					<xul:toolbarbutton
						anonid="close-button"
						class="tabs-closebutton toolbarbutton-1"
						tooltiptext="&splitbrowser.subbrowser.close.tooltip;"
						oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.close();"
						ondblclick="event.stopPropagation();"/>
				</xul:toolbar>
				</xul:toolbox>
				<xul:hbox class="subbrowser-browser-box"
					flex="1"
					onkeypress="if ('findBar_OnBrowserKeyPress' in window) findBar_OnBrowserKeyPress(event);"
					onmouseup="if ('findBar_OnBrowserMouseUp' in window) findBar_OnBrowserMouseUp(event);">
					<xul:tabbrowser anonid="browser-tabbrowser"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onnewtab="
							var node = this;
							while (node.localName != 'tabbrowser') {
								node = node.parentNode;
							}
							node.parentNode.openNewTab();
						"
						onclick="return contentAreaClick(event, false);"
						ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
						content="about:blank"
						contenttooltip="aHTMLTooltip"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"
						disablehistory="true"/>
					<xul:browser anonid="browser-simple"
						class="subbrowser-browser"
						flex="1"
						type="content"
						onclick="return contentAreaClick(event, false);"
						ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.parentNode.pageDNDObserver);"
						content="about:blank"
						contenttooltip="aHTMLTooltip"
						contextmenu="contentAreaContextMenu"
						contentcontextmenu="contentAreaContextMenu"
						autocompletepopup="PopupAutoComplete"/>
				</xul:hbox>
			</xul:vbox>
		</xul:hbox>
	</content>

	<implementation>
		<property name="toolbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbar-horizontal');"/>

		<property name="hToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-horizontal');"/>
		<property name="vToolbox" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'subbrowser-toolbox-vertical');"/>

		<property name="toolbarDeck" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar-deck');"/>

		<property name="browser" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'browser-'+this.browserType);"/>
		<property name="browserType" readonly="true"
			onget="return this.getAttribute('browsertype') == 'simple' ? 'simple' : 'tabbrowser' ;"/>

		<property name="backButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'back-button');"/>
		<property name="forwardButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'forward-button');"/>
		<property name="reloadButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'reload-button');"/>
		<property name="stopButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'stop-button');"/>
		<property name="urlbar" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar');"/>
		<property name="title" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'title');"/>
		<property name="vTitle" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-title');"/>
		<property name="favicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'favicon');"/>
		<property name="vFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'vertical-favicon');"/>
		<property name="urlbarFavicon" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-favicon');"/>
		<property name="progressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'progressmeter');"/>
		<property name="urlbarProgressmeter" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'urlbar-progressmeter');"/>
		<property name="goButton" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'go-button');"/>
		<property name="contextmenu" readonly="true"
			onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'contextmenu');"/>

		<property name="src"
			onset="this.setAttribute('src', val); this.load(val); return val;"
			onget="return this.getAttribute('src') || 'about:blank';"/>

		<method name="load">
			<parameter name="aURI"/>
			<body><![CDATA[
				if (!aURI) aURI = 'about:blank';
				this.browser.loadURI(aURI);
				this.setAttribute('src', aURI);
			]]></body>
		</method>

		<method name="goBack">
			<body><![CDATA[
				if (this.browser.canGoBack) {
					this.browser.goBack();
				}
			]]></body>
		</method>
		<method name="goForward">
			<body><![CDATA[
				if (this.browser.canGoForward) {
					this.browser.goForward();
				}
			]]></body>
		</method>
		<method name="reload">
			<body><![CDATA[
				this.browser.reload();
			]]></body>
		</method>
		<method name="stop">
			<body><![CDATA[
				this.browser.stop();
			]]></body>
		</method>

		<method name="go">
			<body><![CDATA[
				this.load(this.urlbar.value);
			]]></body>
		</method>

		<method name="close">
			<body><![CDATA[
				var event = document.createEvent('Events');
				event.initEvent('SubBrowserRemoveRequest', false, true);
				this.dispatchEvent(event);
			]]></body>
		</method>


		<property name="minSize" readonly="true">
			<getter><![CDATA[
				if (this.mMinSize < 0)
					this.mMinSize = Math.max(this.vToolbox.boxObject.width, this.hToolbox.boxObject.height) * 2;

				return this.mMinSize;
			]]></getter>
		</property>
		<field name="mMinSize">
			-1
		</field>

		<property name="vContentCollapsed" readonly="true"
			onget="return this.boxObject.height &lt;= this.minSize;"/>
		<property name="hContentCollapsed" readonly="true"
			onget="return this.boxObject.width &lt;= this.minSize;"/>
		<property name="vContentCompletelyCollapsed" readonly="true"
			onget="return this.vContentCollapsed"/>
		<property name="hContentCompletelyCollapsed" readonly="true"
			onget="return this.hContentCollapsed"/>

		<method name="updateContextMenu">
			<parameter name="aEvent"/>
			<body><![CDATA[
				var popup = this.contextmenu;
				var collapsed = this.contentCollapsed;
				popup.getElementsByAttribute('class', 'subbrowser-context-collapse')[0].hidden = collapsed;
				popup.getElementsByAttribute('class', 'subbrowser-context-expand')[0].hidden = !collapsed;

				var tabItem = popup.getElementsByAttribute('class', 'subbrowser-context-openNewTab')[0];
				tabItem.hidden = tabItem.previousSibling.hidden = (this.browser.localName != 'tabbrowser');
			]]></body>
		</method>



		<method name="updateToolbarForCurrentTab">
			<parameter name="aSwitchTab"/>
			<body><![CDATA[
				var b      = this.browser;
				var t      = null;
				var isBusy = this.mIsBusy;
				if (aSwitchTab) {
					t = b.mCurrentTab;
					isBusy = (t.getAttribute('busy') == 'true');
					this.mTotalProgress = t.mSubbrowserTabTotalProgress || 0 ;
				}

				if (this.mTotalProgress &&
					this.mTotalProgress < 1) {
					this.progressmeter.removeAttribute('collapsed');
					this.progressmeter.setAttribute('mode', 'normal');
					this.progressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));

					this.urlbarProgressmeter.removeAttribute('collapsed');
					this.urlbarProgressmeter.setAttribute('mode', 'normal');
					this.urlbarProgressmeter.setAttribute('value', parseInt(this.mTotalProgress * 100));
				}
				else {
					this.progressmeter.setAttribute('collapsed', true);
					this.urlbarProgressmeter.setAttribute('collapsed', true);
				}

				if (!isBusy) {
					this.stopButton.setAttribute('disabled', true);
					this.reloadButton.removeAttribute('disabled');

					if (t) {
						this.setIcon(t.getAttribute('image'));
					}
					else if (!this.mIconURL) {
						this.useDefaultIcon();
					}

					this.mIsBusy = false;
					this.removeAttribute('busy');

					try {
						if (b.canGoBack)
							this.backButton.removeAttribute('disabled');
						else
							this.backButton.setAttribute('disabled', true);

						if (b.canGoForward)
							this.forwardButton.removeAttribute('disabled');
						else
							this.forwardButton.setAttribute('disabled', true);
					}
					catch(e) {
						this.backButton.setAttribute('disabled', true);
						this.forwardButton.setAttribute('disabled', true);
					}

					var title = b.contentDocument.title || this.title.getAttribute('blank-label');
					this.title.setAttribute('value', title);
					while (this.vTitle.hasChildNodes())
						this.vTitle.removeChild(this.vTitle.firstChild);
					this.vTitle.appendChild(document.createTextNode(
						title.replace(/(.)/g, '$1\n')
							.replace(/:/g, '..')
							.replace(/;/g, ',.')
							.replace(/[(\[\{<\uff1c\uff08\u300c\uff5b\u3014\u300e\u3008\u300a\u3010\uff3b\u226a]/g, '\u2227')
							.replace(/[)\]\}>\uff1e\uff09\u300d\uff5d\u3015\u300f\u3009\u300b\u3011\uff3d\u226b]/g, '\u2228')
							.replace(/\|/g, '<->')
							.replace(/^[-\u2015\u30fc\uff0d\uff70]$/mg, '|')
							.replace(/<->/mg, '--')
					));
					this.setAttribute('tooltiptext', title);
					this.updateIcon();
				}
				else {
					this.stopButton.removeAttribute('disabled');
					this.reloadButton.setAttribute('disabled', true);

					this.mIsBusy = true;
					this.setAttribute('busy', true);
					var title = this.title.getAttribute('loading-label');
					this.title.setAttribute('value', title);
					while (this.vTitle.hasChildNodes())
						this.vTitle.removeChild(this.vTitle.firstChild);
					this.vTitle.appendChild(document.createTextNode(
						title.replace(/(.)/g, '$1\n')
							.replace(/:/g, '..')
							.replace(/;/g, ',.')
							.replace(/[(\[\{<\uff1c\uff08\u300c\uff5b\u3014\u300e\u3008\u300a\u3010\uff3b\u226a]/g, '\u2227')
							.replace(/[)\]\}>\uff1e\uff09\u300d\uff5d\u3015\u300f\u3009\u300b\u3011\uff3d\u226b]/g, '\u2228')
							.replace(/\|/g, '<->')
							.replace(/^[-\u2015\u30fc\uff0d\uff70]$/mg, '|')
							.replace(/<->/mg, '--')
					));
					this.setAttribute('tooltiptext', title);
					this.updateIcon();
				}
			]]></body>
		</method>



		<method name="toggleNavigation">
			<parameter name="aShow"/>
			<body><![CDATA[
				this.toolbarDeck.setAttribute('selectedIndex', aShow ? '1' : '0' );
				if (this.mToggleNavigationOnHoverTimer) {
					window.clearTimeout(this.mToggleNavigationOnHoverTimer);
					this.mToggleNavigationOnHoverTimer = null;
				}
			]]></body>
		</method>

		<method name="toggleNavigationOnHover">
			<parameter name="aShow"/>
			<parameter name="aForce"/>
			<parameter name="aDelay"/>
			<body><![CDATA[
				if (this.getAttribute('toolbar-navigation') == 'true') return;

				if (this.contentCollapsed) aShow = false;

				if (this.mIsToolbarHover == aShow) {
					if (!aShow && this.mToggleNavigationOnHoverTimer) {
						window.clearTimeout(this.mToggleNavigationOnHoverTimer);
						this.mToggleNavigationOnHoverTimer = null;
					}
					return;
				}

				this.mIsToolbarHover = aShow;

				if (aForce && aDelay === void(0)) {
					this.toggleNavigation(aShow);
					return;
				}

				this.mToggleNavigationOnHoverTimer = window.setTimeout(
					function(aShowFlag, aThis) {
						if (aShowFlag == aThis.mIsToolbarHover &&
							aThis.toolbarDeck)
							aThis.toggleNavigation(aShowFlag);
						aThis.mToggleNavigationOnHoverTimer = null;
					},
					(
						aDelay !== void(0) ? aDelay :
							this.mIsToolbarHover ?
								SplitBrowser.subBrowserToolbarShowDelay :
								SplitBrowser.subBrowserToolbarHideDelay
					),
					aShow,
					this
				);
			]]></body>
		</method>
		<field name="mToggleNavigationOnHoverTimer">null</field>

		<method name="resetNavigation">
			<body><![CDATA[
				if (this.getAttribute('toolbar-navigation') != 'true')
					this.toggleNavigation(false);
			]]></body>
		</method>





		<method name="setIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				this.mIconURL = aURI;
				this.updateIcon();
			]]></body>
		</method>

		<method name="updateIcon">
			<body><![CDATA[
				if (!this.mIsBusy && this.mIconURL) {
					this.favicon.setAttribute('src', this.mIconURL);
					this.vFavicon.setAttribute('src', this.mIconURL);
					this.urlbarFavicon.setAttribute('src', this.mIconURL);
				}
				else {
					this.favicon.removeAttribute('src');
					this.vFavicon.removeAttribute('src');
					this.urlbarFavicon.removeAttribute('src');
				}
			]]></body>
		</method>

		<method name="useDefaultIcon">
			<body><![CDATA[
				if (this.browser.contentDocument instanceof ImageDocument) {
					if (nsPreferences.getBoolPref('browser.chrome.site_icons')) {
						try {
							var sz = nsPreferences.getIntPref('browser.chrome.image_icons.max_size');
							if (!sz)
								return;
							var req = this.browser.contentDocument.imageRequest;
							if (!req || !req.image || req.image.width > sz || req.image.height > sz)
								return;
							this.setIcon(this.browser.currentURI.spec);
						}
						catch (e) {
						}
					}
				}
				else if (this.shouldLoadFavIcon(this.browser.currentURI)) {
					var url = this.browser.currentURI.prePath + '/favicon.ico';
					if (!this.isIconKnownMissing(url))
						this.setIcon(url);
				}
			]]></body>
		</method>

		<method name="shouldLoadFavIcon">
			<parameter name="aURI"/>
			<body><![CDATA[
				return (
					aURI &&
					nsPreferences.getBoolPref('browser.chrome.site_icons') &&
					nsPreferences.getBoolPref('browser.chrome.favicons') &&
					('schemeIs' in aURI) &&
					(aURI.schemeIs('http') || aURI.schemeIs('https'))
				);
			]]></body>
		</method>

		<method name="addToMissedIconCache">
			<parameter name="aURI"/>
			<body><![CDATA[
				var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);
				if (!entry) return;

				if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)
					entry.setMetaDataElement('Icon', 'Missed');
				entry.markValid();
				entry.close();
			]]></body>
		</method>

		<method name="openCacheEntry">
			<parameter name="aKey"/>
			<parameter name="aAccess"/>
			<body><![CDATA[
				try {
					if (!this.mMissedIconCache) {
						var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);
						this.mMissedIconCache = cacheService.createSession('MissedIconCache', Components.interfaces.nsICache.STORE_ANYWHERE, true);
						if (!this.mMissedIconCache) return null;
					}
					return this.mMissedIconCache.openCacheEntry(aKey, aAccess, true);
				}
				catch (e) {
					return null;
				}
			]]></body>
		</method>

		<method name="isIconKnownMissing">
			<parameter name="aKey"/>
			<body><![CDATA[
				var e = this.openCacheEntry(aKey, Components.interfaces.nsICache.ACCESS_READ);
				if (e) {
					e.close();
					return true;
				}
				return false;
			]]></body>
		</method>

		<method name="onLinkAdded">
			<parameter name="aEvent"/>
			<body><![CDATA[
				if (!nsPreferences.getBoolPref('browser.chrome.site_icons')) return;
				if (!aEvent.originalTarget.rel.match((/(?:^|\s)icon(?:\s|$)/i))) return;

				var href = aEvent.originalTarget.href;
				if (!href) return;

				const nsIContentPolicy = Components.interfaces.nsIContentPolicy;
				try {
					var contentPolicy = Components.classes['@mozilla.org/layout/content-policy;1'].getService(nsIContentPolicy);
				}
				catch(e) {
					return;
				}

				const secMan = Components.classes['@mozilla.org/scriptsecuritymanager;1'].getService(Components.interfaces.nsIScriptSecurityManager);
				const ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);
				const targetDoc = aEvent.target.ownerDocument;
				var uri = ioService.newURI(href, targetDoc.characterSet, null);
				var origURI = ioService.newURI(targetDoc.documentURI, targetDoc.characterSet, null);

				const nsIScriptSecMan = Components.interfaces.nsIScriptSecurityManager;
				try {
					const aboutNeterr = 'about:neterror?';
					if (origURI.spec.substr(0, aboutNeterr.length) != aboutNeterr ||
						!uri.schemeIs('chrome'))
						secMan.checkLoadURI(origURI, uri, nsIScriptSecMan.DISALLOW_SCRIPT);
				}
				catch(e) {
					return;
				}

				if (contentPolicy.shouldLoad(
						nsIContentPolicy.TYPE_IMAGE,
						uri,
						origURI,
						aEvent.target,
						aEvent.target.type,
						null
					) != nsIContentPolicy.ACCEPT)
					return;

				if (targetDoc == this.browser.contentDocument)
					this.setIcon(href);
			]]></body>
		</method>



		<field name="pageDNDObserver"><![CDATA[
		({
			mOwner : this,

			onDragStart: function (aEvent, aXferData, aDragAction)
			{
				var value = this.mOwner.src;
				if (!value) return;

				var urlString = value + '\n' + this.mOwner.browser.contentDocument.title;
				var htmlString = '<a href="' + value + '">' + value + '</a>';

				aXferData.data = new TransferData();

				aXferData.data.addDataForFlavour('application/x-moz-splitbrowser',
					[
						'subbrowser',
						'id:'+this.mOwner.id,
						'uri:'+value,
						'width:'+this.mOwner.boxObject.width,
						'height:'+this.mOwner.boxObject.height
					].join('\n')
				);

				aXferData.data.addDataForFlavour('text/x-moz-url', urlString);
				aXferData.data.addDataForFlavour('text/unicode', value);
				aXferData.data.addDataForFlavour('text/html', htmlString);

				aDragAction.action =
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_COPY |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_MOVE |
					Components.interfaces.nsIDragService.DRAGDROP_ACTION_LINK;
			},

			onDragOver : function() {
			},

			onDrop: function (aEvent, aXferData, aDragSession)
			{
				aEvent.preventDefault();
				aEvent.stopPropagation();

				var uri = SplitBrowser.getURIFromDragData(aXferData, aDragSession, aEvent);
				if (!uri) return;

				// fallback for Linux
				// in Linux, "dragdrop" event doesn't fire on the button.
				var forceCheck = aEvent.ctrlKey || aXferData.flavour.contentType == 'application/x-moz-splitbrowser';
				var check = this.mOwner.checkEventFiredOnEdge(aEvent, forceCheck);
				if (!check) return;

				if (
					(forceCheck || SplitBrowser.isLinux) &&
					SplitBrowser.addButton.targetSubBrowser == this.mOwner &&
					(
						check.isTop ||
						check.isBottom ||
						check.isLeft ||
						check.isRight
					)
					) {
					SplitBrowser.fireSubBrowserAddRequestEventFromButton(uri);
					return;
				}

				this.mOwner.load(uri);
			},

			getSupportedFlavours: function ()
			{
				var flavourSet = new FlavourSet();
				flavourSet.appendFlavour('application/x-moz-splitbrowser');
				flavourSet.appendFlavour('text/x-moz-url');
				flavourSet.appendFlavour('text/unicode');
				flavourSet.appendFlavour('application/x-moz-file', 'nsIFile');
				return flavourSet;
			}
		})
		]]></field>


		<method name="openNewTab">
			<body><![CDATA[
				var b = this.browser;
				var t = b.addTab('about:blank');
				this.toggleNavigation(true);
				window.setTimeout(function(aUrlbar) {
					b.selectedTab = t;
					window.setTimeout(function(aUrlbar) {
						aUrlbar.value = '';
						aUrlbar.focus();
					}, 0, aUrlbar);
				}, 0, this.urlbar);
			]]></body>
		</method>

		<method name="newAddTab">
			<body><![CDATA[
				var tab = this.__splitbrowser__addTab.apply(this, arguments);
				if (this.parentSubBrowser)
					this.parentSubBrowser.addProgressListener(tab);

				return tab;
			]]></body>
		</method>

		<method name="newRemoveTab">
			<body><![CDATA[
				if (this.parentSubBrowser)
					this.parentSubBrowser.removeProgressListener(arguments[0]);

				var result = this.__splitbrowser__removeTab.apply(this, arguments);

				if (this.mTabContainer.childNodes.length == 1) {
					this.setStripVisibilityTo(!nsPreferences.getBoolPref('splitbrowser.tabs.autoHide'));
				}

				return result;
			]]></body>
		</method>

		<method name="newUpdateCurrentBrowser">
			<body><![CDATA[
				var result = this.__splitbrowser__updateCurrentBrowser.apply(this, arguments);

				if (this.parentSubBrowser.focused) {
					SplitBrowser.mainBrowserBox.blur();
				}
				else {
					var node = SplitBrowser.activeSubBrowser;
					this.parentSubBrowser.blur();
					if (node)
						node.focus();
				}

				return result;
			]]></body>
		</method>

		<method name="addProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;

				var filter = Components.classes['@mozilla.org/appshell/component/browser-status-filter;1'].createInstance(Components.interfaces.nsIWebProgress);
				var listener = this.createProgressListener(aTab, browser);
				filter.addProgressListener(listener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
				browser.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);

				this.mTabListeners.push(listener);
				this.mTabFilters.push(filter);
			]]></body>
		</method>

		<method name="removeProgressListener">
			<parameter name="aTab"/>
			<body><![CDATA[
				var browser = aTab ? this.browser.getBrowserForTab(aTab) : this.browser ;
				var count = 0;

				if (aTab) {
					for (count = 0, maxc = this.mTabListeners.length; count < maxc; count++)
					{
						if (this.mTabListeners[count].mTab == aTab) break;
					}
				}

				delete this.mTabListeners[count].mOwner;
				delete this.mTabListeners[count].mTab;
				delete this.mTabListeners[count].mBrowser;

				browser.webProgress.removeProgressListener(this.mTabFilters[count]);
				this.mTabFilters[count].removeProgressListener(this.mTabListeners[count]);
				this.mTabFilters.splice(count, 1);
				this.mTabListeners.splice(count, 1);
			]]></body>
		</method>

		<method name="createProgressListener">
			<parameter name="aTab"/>
			<parameter name="aBrowser"/>
			<body><![CDATA[
			return {

			mOwner         : this,
            mTab           : aTab,
            mBrowser       : aBrowser,
            mTotalProgress : 0,

			onProgressChange: function (aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress)
			{
				this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
				if (this.mTab)
					this.mTab.mSubbrowserTabTotalProgress = this.mTotalProgress;

				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.mTotalProgress = this.mTotalProgress;
				this.mOwner.updateToolbarForCurrentTab();
			},

			onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
				if (
					aStateFlags & nsIWebProgressListener.STATE_START &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = true;
					this.mOwner.updateToolbarForCurrentTab();
				}
				else if (
					aStateFlags & nsIWebProgressListener.STATE_STOP &&
					aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK
					) {
					this.mOwner.mIsBusy = false;
					this.mOwner.updateToolbarForCurrentTab();
				}
			},

			onLocationChange : function(aWebProgress, aRequest, aLocation)
			{
				if (this.mTab && this.mTab != this.mOwner.browser.mCurrentTab) return;

				this.mOwner.urlbar.value = aLocation.spec;
				this.mOwner.setAttribute('src', aLocation.spec);

				if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
					aWebProgress.isLoadingDocument)
					this.mOwner.setIcon(null);
			},

			onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
			{
			},

			onSecurityChange : function(aWebProgress, aRequest, aState)
			{
			},

			QueryInterface : function(aIID)
			{
				if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
					aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
					aIID.equals(Components.interfaces.nsISupports))
					return this;
				throw Components.results.NS_NOINTERFACE;
			}

			};
			]]></body>
		</method>

		<field name="mTabListeners">[]</field>
		<field name="mTabFilters">[]</field>

		<constructor><![CDATA[
			var b = this.browser;
			if (b.nextSibling && b.nextSibling.localName == 'browser')
				b.parentNode.removeChild(b.nextSibling);
			if (b.previousSibling && b.previousSibling.localName == 'tabbrowser')
				b.parentNode.removeChild(b.previousSibling);

			b.parentSubBrowser = this;

			if (nsPreferences.getBoolPref('splitbrowser.show.toolbar.navigation.always')) {
				this.setAttribute('toolbar-navigation', true);
				this.toggleNavigation(true);
			}

			if (b.localName == 'tabbrowser') {
				b.__splitbrowser__addTab = b.addTab;
				b.addTab = this.newAddTab;
				b.__splitbrowser__removeTab = b.removeTab;
				b.removeTab = this.newRemoveTab;
				b.__splitbrowser__updateCurrentBrowser = b.updateCurrentBrowser;
				b.updateCurrentBrowser = this.newUpdateCurrentBrowser;

				b.mTabContainer.addEventListener('select', this.onTabSelectHandler, false);

				window.setTimeout(this.mDelayedTabbrowserStartup, 0, this);

				var newEvent = document.createEvent('Events');
				newEvent.tabbrowser = b;
				newEvent.initEvent('SubBrowserTabbrowserInserted', false, true);
				this.dispatchEvent(newEvent);
			}
			else {
				this.addProgressListener(null);

				window.setTimeout(this.mDelayedBrowserStartup, 0, this);

				if (this.getAttribute('src'))
					this.load(this.getAttribute('src'));
			}
		]]></constructor>

		<method name="mDelayedBrowserStartup">
			<parameter name="aThis"/>
			<body><![CDATA[
				aThis.blur();
				aThis.mUpdateToolbarMode();

				var newEvent = document.createEvent('Events');
				newEvent.initEvent('SubBrowserAdded', false, true);
				aThis.dispatchEvent(newEvent);
			]]></body>
		</method>
		<method name="mDelayedTabbrowserStartup">
			<parameter name="aThis"/>
			<body><![CDATA[
			aThis.mDelayedBrowserStartup(aThis);

			var b = aThis.browser;
			aThis.addProgressListener(b.mCurrentTab);

			var autoHide = nsPreferences.getBoolPref('splitbrowser.tabs.autoHide');
			b.setStripVisibilityTo(!autoHide);

			b = b.mCurrentBrowser;
			b.webNavigation.sessionHistory = Components.classes['@mozilla.org/browser/shistory;1'].createInstance(Components.interfaces.nsISHistory);

			var os = Components.classes['@mozilla.org/observer-service;1'].getService(Components.interfaces.nsIObserverService);
			os.addObserver(b, 'browser:purge-session-history', false);
			b.removeAttribute('disablehistory');
			b.docShell.QueryInterface(Components.interfaces.nsIDocShellHistory).useGlobalHistory = true;

			if (aThis.getAttribute('src'))
				aThis.load(aThis.getAttribute('src'));
			]]></body>
		</method>


		<method name="destroy">
			<body><![CDATA[
				if (this.focused) {
					gBrowser.contentWindow.focus();
				}
				this.blur();

				var b = this.browser;
				if (b.localName == 'tabbrowser') {
					if (b.mCurrentBrowser.getAttribute('type') == 'content-primary')
						document.getElementById('appcontent').contentWrapper.focus();

					b.mCurrentBrowser.removeAttribute('type');
					b.mCurrentBrowser.setAttribute('type', 'content');
					for (var i = 0, maxi = b.mTabContainer.childNodes.length; i < maxi; i++)
					{
						this.removeProgressListener(b.mTabContainer.childNodes[i]);
						try {
							b.browsers[i].destroy();
						}
						catch(e) {
						}
					}
					b.mTabContainer.removeEventListener('select', this.onTabSelectHandler, false);
				}
				else {
					if (b.getAttribute('type') == 'content-primary')
						document.getElementById('appcontent').contentWrapper.focus();

					b.removeAttribute('type');
					b.setAttribute('type', 'content');
					this.removeProgressListener();

					try {
						b.destroy();
					}
					catch(e) {
					}
				}

				var newEvent = document.createEvent('Events');
				newEvent.initEvent('SubBrowserRemoved', false, true);
				document.documentElement.dispatchEvent(newEvent);

				b.parentSubBrowser = null;

				b.parentNode.removeChild(b);
			]]></body>
		</method>


		<field name="onTabSelectHandler"><![CDATA[
			({
				mOwner      : this,
				handleEvent : function(aEvent)
				{
					switch (aEvent.type)
					{
						case 'select':
							this.mOwner.updateToolbarForCurrentTab(true);

							var newEvent = document.createEvent('Events');
							newEvent.initEvent('SubBrowserTabSelect', false, true);
							newEvent.targetTab = this.mOwner.browser.selectedTab;
							this.mOwner.dispatchEvent(newEvent);
							break;
					}
				}
			})
		]]></field>

		<method name="mUpdateToolbarMode">
			<body><![CDATA[
				var c = this.flexibleParent;
				while (c && c.parentNode && !c.splitterDragging)
					c = c.parentNode;
				if (c && c == document) c = null;

				var collapse;

				var toolbarShown = nsPreferences.getBoolPref('splitbrowser.show.toolbar.always');

				if (this.boxObject.width <= this.minSize) {
					if (this.boxObject.height <= this.minSize) {
						this.setAttribute('toolbar-mode', 'horizontal');
						if (c && toolbarShown) c.setAttribute('maxheight', 0);
					}
					else {
						this.setAttribute('toolbar-mode', 'vertical');
						if (c && toolbarShown) c.setAttribute('maxwidth', 0);
					}
					collapse = true;
				}
				else {
					this.setAttribute('toolbar-mode', 'horizontal');
					if (this.boxObject.height <= this.minSize) {
						if (c && toolbarShown) c.setAttribute('maxheight', 0);
						collapse = true;
					}
					else {
						collapse = false;
					}
				}

				if (collapse) {
					if (!this.contentCollapsed)
						this.collapse();

					this.setAttribute('content-collapsed', 'true');
					if (this.getAttribute('toolbar-navigation') == 'true')
						this.toggleNavigation(false);

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserContentCollapsed', false, true);
					document.documentElement.dispatchEvent(newEvent);
				}
				else {
					this.removeAttribute('content-collapsed');
					if (this.getAttribute('toolbar-navigation') == 'true')
						this.toggleNavigation(true);

					var newEvent = document.createEvent('Events');
					newEvent.initEvent('SubBrowserContentExpanded', false, true);
					document.documentElement.dispatchEvent(newEvent);
				}
			]]></body>
		</method>

	</implementation>

	<handlers>
		<handler event="DOMLinkAdded" phase="capturing"
			action="this.onLinkAdded(event);"/>

		<handler event="resize"
			action="this.mUpdateToolbarMode();"/>

		<handler event="click"
			action="if (!this.contentCollapsed) this.browser.contentWindow.focus();"/>

	</handlers>
</binding>


</bindings>
