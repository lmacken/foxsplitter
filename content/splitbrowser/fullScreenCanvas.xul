<?xml version="1.0"?>
<!--
 Full Screen Canvas

 Usage:
   window.fullScreenCanvas.show();
   ... // do something
   window.fullScreenCanvas.hide();
   var zoom = window.fullScreenCanvas.getZoomForFrame(window.content);

 lisence: The MIT License, Copyright (c) 2009 SHIMODA "Piro" Hiroshi
   http://www.cozmixng.org/repos/piro/fx3-compatibility-lib/trunk/license.txt
 original:
   http://www.cozmixng.org/repos/piro/fx3-compatibility-lib/trunk/fullScreenCanvas.xul
-->
<overlay xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
<script type="application/x-javascript; version=1.7"><![CDATA[

window.addEventListener('DOMContentLoaded', function() {
	window.removeEventListener('DOMContentLoaded', arguments.callee, true);

	const currentRevision = 11;
	var root = document.documentElement;

	var loadedRevision = root.getAttribute('fullScreenCanvas');
	if (loadedRevision) {
		loadedRevision = Number(loadedRevision);
		if (loadedRevision >= currentRevision) {
			return;
		}
		else if (loadedRevision < currentRevision) {
			root.setAttribute('fullScreenCanvas', currentRevision);
			window.fullScreenCanvas.destroy();
		}
	}

	window.fullScreenCanvas = {
		show : function(aTargetElement, aCallback, aThis) 
		{
			this.doShow(aTargetElement);
			if (!aCallback) return;
			if (this.shown) {
				var self = this;
				this.panel.addEventListener('popupshown', function() {
					self.panel.removeEventListener('popupshown', arguments.callee, false);
					aCallback.call(aThis || window);
				}, false);
			}
			else {
				aCallback.call(aThis || window);
			}
		},
		doShow : function(aTargetElement) 
		{
			if (this.shown) return;

			var color = '-moz-field';
			var canvas = this.canvas;
			if (!canvas) return;

			this.shown = true;

			var rootBox = document.documentElement.boxObject;
			var canvasW = window.innerWidth;
			var canvasH = window.innerHeight;

			var x, y, w, h;
			if (aTargetElement && aTargetElement.ownerDocument == document) {
				let box = aTargetElement.boxObject;
				x = box.screenX - rootBox.screenX;
				y = box.screenY - rootBox.screenY;
				w = box.width;
				h = box.height;
			}
			else {
				x = y = 0;
				w = canvasW;
				h = canvasH;
			}

			this.panel.style.width = canvas.style.width  = (canvas.width = canvasW)+'px';
			this.panel.style.height = canvas.style.height = (canvas.height = canvasH)+'px';
			try {
				var ctx = canvas.getContext('2d');
				ctx.clearRect(0, 0, canvasW, canvasH);
				ctx.save();
				ctx.translate(x, y);
				ctx.drawWindow(window, x, y, w, h, color);
				ctx.restore();

				var browsers = this.browsers;
				var self = this;
				browsers.forEach(function(aBrowser) {
				try {
					var b = aBrowser;
					if (b.localName == 'subbrowser') b = b.browser;
					var TST = b.treeStyleTab;
					var frame = b.contentWindow;
					var zoom = self.getZoomForFrame(frame);
					var x = (b.localName == 'tabbrowser' ? b.mCurrentBrowser : b ).boxObject.x;
					var y = (b.localName == 'tabbrowser' ? b.mCurrentBrowser : b ).boxObject.y;
					var w = frame.innerWidth;
					var h = frame.innerHeight;
					var dx = 0;
					var dy = 0;
					if (
						TST &&
						('autoHide' in TST ?
							(TST.autoHide.enabled && TST.autoHide.shown) :
							(TST.autoHideEnabled && TST.autoHideShown) // backward compatibility
						)
						) {
						var pos = b.getAttribute(TST.kTABBAR_POSITION);
						var xOffset = 'autoHide' in TST ? TST.autoHide.XOffset :
										'autoHideXOffset' in TST ? TST.autoHideXOffset :
										TST.tabbarWidth ;
						var yOffset = 'autoHide' in TST ? TST.autoHide.YOffset :
										'autoHideYOffset' in TST ? TST.autoHideYOffset :
										TST.tabbarHeight ;
						switch (pos)
						{
							case 'left':
								dx = xOffset / zoom;
								w -= xOffset / zoom;
								break;
							case 'right':
								x += xOffset / zoom;
								w -= xOffset / zoom;
								break;
							case 'top':
								dy = yOffset / zoom;
								h -= yOffset / zoom;
								break;
							case 'bottom':
								y += yOffset / zoom;
								h -= yOffset / zoom;
								break;
						}
					}
					ctx.save();
					ctx.translate(x, y);
					ctx.scale(zoom, zoom);
					ctx.drawWindow(frame, dx+frame.scrollX, dy+frame.scrollY, w, h, color);
					ctx.restore();
				}
				catch(e) {
				}
				});

				this.panel.openPopupAtScreen(rootBox.screenX, rootBox.screenY, false);
			}
			catch(e) {
				this.hide();
			}
		},
		shown : false,

		getZoomForFrame : function(aFrame)
		{
			const Prefs = Components
					.classes['@mozilla.org/preferences;1']
					.getService(Components.interfaces.nsIPrefBranch);
			try {
				if (Prefs.getBoolPref('browser.zoom.full')) {
					var zoom = aFrame
						.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
						.getInterface(Components.interfaces.nsIWebNavigation)
						.QueryInterface(Components.interfaces.nsIDocShell)
						.contentViewer
						.QueryInterface(Components.interfaces.nsIMarkupDocumentViewer)
						.fullZoom;
					return (zoom * 1000 % 1) ? zoom+0.025 : zoom ;
				}
			}
			catch(e) {
			}
			return 1;
		},

		hide : function()
		{
			if (!this.shown) return;
			this.panel.hidePopup();
			this.shown = false;
		},

		onClick : function(aEvent)
		{
			if (window['piro.sakura.ne.jp'] &&
				window['piro.sakura.ne.jp'].boxObject)
				this.setUpClickEvent(aEvent);

			this.hide();
		},


		// resend click event
		setUpClickEvent : function(aEvent)
		{
			var x, y, target;
			if (!this.browsers.some(function(aBrowser) {
					var box = (aBrowser.localName == 'tabbrowser' ? aBrowser.mCurrentBrowser : aBrowser )
								.boxObject;
					if (!this._isInside(box, aEvent.screenX, aEvent.screenY))
						return false;

					var frame = this.getFrameElementFromScreenPoint(
							aBrowser,
							aEvent.screenX,
							aEvent.screenY
						);
					if (!frame)
						return false;

					target = frame.contentWindow;
					var box = this.getBoxObjectFor(frame);
					x = aEvent.screenX - box.screenX;
					y = aEvent.screenY - box.screenY;
					return true;
				}, this)) {
				x = aEvent.clientX;
				y = aEvent.clientY;
				target = window;
			}

			var flags = 0;
			const nsIDOMNSEvent = Components.interfaces.nsIDOMNSEvent;
			if (aEvent.altKey) flags |= nsIDOMNSEvent.ALT_MASK;
			if (aEvent.ctrlKey) flags |= nsIDOMNSEvent.CONTROL_MASK;
			if (aEvent.shiftKey) flags |= nsIDOMNSEvent.SHIFT_MASK;
			if (aEvent.metaKey) flags |= nsIDOMNSEvent.META_MASK;

			var button = aEvent.button;

			var self = this;
			this.panel.addEventListener('popuphidden', function() {
				self.panel.removeEventListener('popuphidden', arguments.callee, false);

				var utils = target
						.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
						.getInterface(Components.interfaces.nsIDOMWindowUtils);
				utils.sendMouseEvent('mousedown', x, y, button, 1, flags);
				utils.sendMouseEvent('mouseup', x, y, button, 1, flags);
			}, false);
		},

		getFrameElementFromScreenPoint : function(aCurrent, aScreenX, aScreenY)
		{
			var frame = aCurrent.contentWindow;
			var clientPos = this._getClientPointFromScreenPoint(frame, aScreenX, aScreenY);
			var elem = frame.document.elementFromPoint(clientPos.x, clientPos.y);
			if (elem)
				elem = this._getOriginalTargetFromScreenPoint(elem, aScreenX, aScreenY);
			if (
				elem &&
				/^(i?frame|browser)$/i.test(elem.localName)
				) {
				return this.getFrameElementFromScreenPoint(
						elem,
						aScreenX + frame.scrollX,
						aScreenY + frame.scrollY
					);
			}
			return aCurrent;
		},

		_getClientPointFromScreenPoint : function(aFrame, aScreenX, aScreenY) 
		{
			var box = this.getBoxObjectFor(aFrame.document.documentElement);
			return {
				x : aScreenX - box.screenX - aFrame.scrollX,
				y : aScreenY - box.screenY - aFrame.scrollY
			};
		},

		_isInside : function(aBox, aScreenX, aScreenY) 
		{
			var left   = aBox.screenX;
			var top    = aBox.screenY;
			var right  = left + aBox.width;
			var bottom = top + aBox.height;
			return !(
					left   > aScreenX ||
					right  < aScreenX ||
					top    > aScreenY ||
					bottom < aScreenY
				);
		},

		_getOriginalTargetFromScreenPoint : function(aElement, aScreenX, aScreenY) 
		{
			return this._getOriginalTargetFromScreenPointInternal(aElement, aScreenX, aScreenY) || aElement;
		},
		_getOriginalTargetFromScreenPointInternal : function(aElement, aScreenX, aScreenY) 
		{
			if (!aElement) return null;
			var doc = aElement.ownerDocument;
			var nodes = 'getAnonymousNodes' in doc ? doc.getAnonymousNodes(aElement) : null ;
			if (!nodes || !nodes.length) nodes = aElement.childNodes;
			if (!nodes || !nodes.length) return null;
			for (var i = 0, maxi = nodes.length; i < maxi; i++)
			{
				if (nodes[i].nodeType != nodes[i].ELEMENT_NODE ||
					!this._isInside(this.getBoxObjectFor(nodes[i]), aScreenX, aScreenY))
					continue;
				var node = this._getOriginalTargetFromScreenPointInternal(nodes[i], aScreenX, aScreenY);
				if (node) return node;
			}
			return null;
		},

		getBoxObjectFor : function(aNode)
		{
			return window['piro.sakura.ne.jp']
						.boxObject
						.getBoxObjectFor(aNode);
		},


		get browsers()
		{
			browsers = [].concat(Array.slice(document.getElementsByTagName('tabbrowser')))
						.concat(Array.slice(document.getElementsByTagName('browser')));
			if ('SplitBrowser' in window) browsers = browsers.concat(SplitBrowser.browsers);
			return browsers;
		},

		get panel()
		{
			return document.getElementById('fullScreenCanvas-panel');
		},

		init : function()
		{
			var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
			canvas.setAttribute('id', 'fullScreenCanvas-canvas');
			canvas.setAttribute('width', '0');
			canvas.setAttribute('height', '0');
			canvas.setAttribute('style', 'width:0;height:0;');
			this.canvas = canvas;
			this.panel.appendChild(canvas);
		},

		destroy : function()
		{
			var range = document.createRange();
			range.selectNodeContents(this.panel);
			range.deleteContents();
			range.detach();
		}
	};

	fullScreenCanvas.init();
}, true);

]]></script>

<window id="main-window">
	<panel id="fullScreenCanvas-panel"
		noautohide="true"
		style="
			-moz-appearance: none;
			-moz-border-top-colors: none;
			-moz-border-right-colors: none;
			-moz-border-bottom-colors: none;
			-moz-border-left-colors: none;
			background: transparent;
			border: 0 none;
			padding: 0;
		"
		onclick="fullScreenCanvas.onClick(event);"/>
</window>

</overlay>
